# gabion:boundary_normalization_module
# gabion:decision_protocol_module
from __future__ import annotations

import re
from typing import Any

from gabion.analysis.timeout_context import check_deadline
from gabion.order_contract import sort_once


def _sanitize_contextvar_identifier(value: str) -> str:
    cleaned = re.sub(r"[^a-zA-Z0-9_]", "_", value).strip("_").lower()
    if not cleaned:
        return "ambient"
    if cleaned[0].isdigit():
        return f"ambient_{cleaned}"
    return cleaned


def _sorted_protocols(plan: dict[str, Any]) -> list[dict[str, Any]]:
    protocols = plan.get("protocols", [])
    if not isinstance(protocols, list):
        return []

    def _key(spec: dict[str, Any]) -> tuple[int, str, tuple[str, ...]]:
        bundle = tuple(
            sort_once(
                (str(name) for name in (spec.get("bundle") or [])),
                source="_sorted_protocols.bundle",
            )
        )
        tier = spec.get("tier")
        tier_key = int(tier) if isinstance(tier, int) else 99
        suggested = str(spec.get("name") or "")
        return (tier_key, suggested, bundle)

    return sort_once(
        [spec for spec in protocols if isinstance(spec, dict)],
        source="render_protocol_stubs.protocols",
        key=_key,
    )


def render_protocol_stubs(plan: dict[str, Any], kind: str = "dataclass") -> str:
    check_deadline()
    protocols = _sorted_protocols(plan)
    if kind not in {"dataclass", "protocol", "contextvar"}:
        kind = "dataclass"
    typing_names = {"Any"}
    if kind == "protocol":
        typing_names.add("Protocol")
    if kind == "contextvar":
        typing_names.update({"ContextVar", "TypeVar"})
    for spec in protocols:
        check_deadline()
        for field in spec.get("fields", []) or []:
            check_deadline()
            hint = field.get("type_hint") or "Any"
            if "Optional[" in hint:
                typing_names.add("Optional")
            if "Union[" in hint:
                typing_names.add("Union")
    typing_import = ", ".join(
        sort_once(
            typing_names,
            source="render_protocol_stubs.typing_names",
        )
    )
    lines = [
        "# Auto-generated by gabion dataflow audit.",
        "from __future__ import annotations",
        "",
        f"from typing import {typing_import}",
        "",
    ]
    if kind == "dataclass":
        lines.insert(3, "from dataclasses import dataclass")
    if not protocols:
        lines.append("# No protocol candidates.")
        return "\n".join(lines)
    if kind == "contextvar":
        lines.extend(
            [
                "_ContextVarT = TypeVar(\"_ContextVarT\")",
                "",
                "",
                "def _read_contextvar(name: str, carrier: ContextVar[_ContextVarT], default: _ContextVarT) -> _ContextVarT:",
                "    \"\"\"Typed helper for reading an ambient context value.\"\"\"",
                "    return carrier.get(default)",
                "",
                "",
            ]
        )
    placeholder_base = "TODO_Name_Me"
    for idx, spec in enumerate(protocols, start=1):
        check_deadline()
        name = placeholder_base if idx == 1 else f"{placeholder_base}{idx}"
        suggested = spec.get("name", "Bundle")
        tier = spec.get("tier", "?")
        bundle = sort_once(
            spec.get("bundle", []),
            source="render_protocol_stubs.bundle",
        )
        rationale = spec.get("rationale", "")
        evidence = sort_once(
            spec.get("evidence", []),
            source="render_protocol_stubs.evidence",
        )
        raw_fields = spec.get("fields", [])
        fields = sort_once(
            [field for field in raw_fields if isinstance(field, dict)],
            source="render_protocol_stubs.fields",
            key=lambda field: str(field.get("name") or "field"),
        )
        if kind == "dataclass":
            lines.append("@dataclass")
            lines.append(f"class {name}:")
        elif kind == "protocol":
            lines.append(f"class {name}(Protocol):")
        doc_lines = [
            "TODO: Rename this Protocol.",
            f"Suggested name: {suggested}",
            f"Tier: {tier}",
        ]
        if bundle:
            doc_lines.append(f"Bundle: {', '.join(bundle)}")
        if rationale:
            doc_lines.append(f"Rationale: {rationale}")
        if fields:
            field_summary = []
            for field in fields:
                check_deadline()
                fname = field.get("name") or "field"
                type_hint = field.get("type_hint") or "Any"
                field_summary.append(f"{fname}: {type_hint}")
            doc_lines.append("Fields: " + ", ".join(field_summary))
        if kind in {"dataclass", "protocol"}:
            lines.append('    """')
            for line in doc_lines:
                check_deadline()
                lines.append(f"    {line}")
            lines.append('    """')
            if not fields:
                lines.append("    pass")
            else:
                for field in fields:
                    check_deadline()
                    fname = field.get("name") or "field"
                    type_hint = field.get("type_hint") or "Any"
                    lines.append(f"    {fname}: {type_hint}")
            lines.append("")
            continue

        lines.append(f"# Suggested ambient bundle: {suggested} (tier {tier})")
        if bundle:
            lines.append(f"# Bundle fields: {', '.join(bundle)}")
        if rationale:
            lines.append(f"# Rationale: {rationale}")
        if evidence:
            lines.append(f"# Evidence: {', '.join(evidence)}")
        unsupported = "control_context" not in set(evidence)
        if unsupported:
            lines.append(
                "# Advisory only: missing control_context evidence; keep this candidate as suggestion-only."
            )
        for field in fields:
            check_deadline()
            fname = str(field.get("name") or "field")
            type_hint = str(field.get("type_hint") or "Any")
            identifier = _sanitize_contextvar_identifier(fname)
            contextvar_name = f"_{identifier}_context"
            lines.append(
                f"{contextvar_name}: ContextVar[{type_hint}] = ContextVar(\"{identifier}\")"
            )
            lines.append("")
            lines.append(
                f"def get_{identifier}(default: {type_hint}) -> {type_hint}:"
            )
            lines.append(
                f"    \"\"\"Read ambient `{fname}` from `{contextvar_name}`.\"\"\""
            )
            lines.append(
                f"    return _read_contextvar(\"{identifier}\", {contextvar_name}, default)"
            )
            lines.append("")
        lines.append("")
    return "\n".join(lines)
