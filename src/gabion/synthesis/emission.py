# gabion:boundary_normalization_module
# gabion:decision_protocol_module
from __future__ import annotations

from collections.abc import Mapping
from dataclasses import dataclass
import re

from gabion.analysis.resume_codec import mapping_or_none, sequence_or_none
from gabion.analysis.timeout_context import check_deadline
from gabion.order_contract import sort_once


def _sanitize_contextvar_identifier(value: str) -> str:
    cleaned = re.sub(r"[^a-zA-Z0-9_]", "_", value).strip("_").lower()
    if not cleaned:
        return "ambient"
    if cleaned[0].isdigit():
        return f"ambient_{cleaned}"
    return cleaned


@dataclass(frozen=True)
class _ProtocolFieldSpec:
    name: str
    type_hint: str


@dataclass(frozen=True)
class _ProtocolSpec:
    suggested_name: str
    tier_sort_key: int
    tier_label: str
    bundle: tuple[str, ...]
    rationale: str
    evidence: tuple[str, ...]
    fields: tuple[_ProtocolFieldSpec, ...]


def _tier_parts(value: object) -> tuple[int, str]:
    match value:
        case int() as tier_value:
            return tier_value, str(tier_value)
        case _:
            return 99, str(value or "?")


def _string_tuple_from_payload(
    payload: Mapping[str, object],
    *,
    key: str,
    source: str,
) -> tuple[str, ...]:
    values = sequence_or_none(payload.get(key))
    if values is None:
        return tuple()
    normalized = []
    for value in values:
        check_deadline()
        normalized.append(str(value))
    return tuple(sort_once(normalized, source=source))


def _field_spec_from_payload(payload: Mapping[str, object]) -> _ProtocolFieldSpec:
    return _ProtocolFieldSpec(
        name=str(payload.get("name") or "field"),
        type_hint=str(payload.get("type_hint") or "Any"),
    )


def _protocol_spec_from_payload(payload: Mapping[str, object]) -> _ProtocolSpec:
    tier_sort_key, tier_label = _tier_parts(payload.get("tier"))
    raw_fields = sequence_or_none(payload.get("fields")) or ()
    field_specs = []
    for raw_field in raw_fields:
        check_deadline()
        parsed_field = mapping_or_none(raw_field) or {}
        field_specs.append(_field_spec_from_payload(parsed_field))
    fields = tuple(
        sort_once(
            field_specs,
            source="render_protocol_stubs.fields",
            key=lambda field: field.name,
        )
    )
    return _ProtocolSpec(
        suggested_name=str(payload.get("name") or "Bundle"),
        tier_sort_key=tier_sort_key,
        tier_label=tier_label,
        bundle=_string_tuple_from_payload(
            payload,
            key="bundle",
            source="_sorted_protocols.bundle",
        ),
        rationale=str(payload.get("rationale") or ""),
        evidence=_string_tuple_from_payload(
            payload,
            key="evidence",
            source="render_protocol_stubs.evidence",
        ),
        fields=fields,
    )


def _protocol_sort_key(spec: _ProtocolSpec) -> tuple[int, str, tuple[str, ...]]:
    return (spec.tier_sort_key, spec.suggested_name, spec.bundle)


def _sorted_protocols(plan: Mapping[str, object]) -> list[_ProtocolSpec]:
    protocols = sequence_or_none(plan.get("protocols"))
    if protocols is None:
        return list()
    normalized: list[_ProtocolSpec] = []
    for raw_protocol in protocols:
        check_deadline()
        parsed_protocol = mapping_or_none(raw_protocol) or {}
        normalized.append(_protocol_spec_from_payload(parsed_protocol))
    return sort_once(
        normalized,
        source="render_protocol_stubs.protocols",
        key=_protocol_sort_key,
    )


def render_protocol_stubs(plan: Mapping[str, object], kind: str = "dataclass") -> str:
    check_deadline()
    protocols = _sorted_protocols(plan)
    if kind not in {"dataclass", "protocol", "contextvar"}:
        kind = "dataclass"
    typing_names = {"Any"}
    if kind == "protocol":
        typing_names.add("Protocol")
    if kind == "contextvar":
        typing_names.update({"ContextVar", "TypeVar"})
    for spec in protocols:
        check_deadline()
        for field in spec.fields:
            check_deadline()
            hint = field.type_hint
            if "Optional[" in hint:
                typing_names.add("Optional")
            if "Union[" in hint:
                typing_names.add("Union")
    typing_import = ", ".join(
        sort_once(
            typing_names,
            source="render_protocol_stubs.typing_names",
        )
    )
    lines = [
        "# Auto-generated by gabion dataflow audit.",
        "from __future__ import annotations",
        "",
        f"from typing import {typing_import}",
        "",
    ]
    if kind == "dataclass":
        lines.insert(3, "from dataclasses import dataclass")
    if not protocols:
        lines.append("# No protocol candidates.")
        return "\n".join(lines)
    if kind == "contextvar":
        lines.extend(
            [
                "_ContextVarT = TypeVar(\"_ContextVarT\")",
                "",
                "",
                "def _read_contextvar(name: str, carrier: ContextVar[_ContextVarT], default: _ContextVarT) -> _ContextVarT:",
                "    \"\"\"Typed helper for reading an ambient context value.\"\"\"",
                "    return carrier.get(default)",
                "",
                "",
            ]
        )
    placeholder_base = "TODO_Name_Me"
    for idx, spec in enumerate(protocols, start=1):
        check_deadline()
        name = placeholder_base if idx == 1 else f"{placeholder_base}{idx}"
        suggested = spec.suggested_name
        tier = spec.tier_label
        bundle = spec.bundle
        rationale = spec.rationale
        evidence = spec.evidence
        fields = spec.fields
        if kind == "dataclass":
            lines.append("@dataclass")
            lines.append(f"class {name}:")
        elif kind == "protocol":
            lines.append(f"class {name}(Protocol):")
        doc_lines = [
            "TODO: Rename this Protocol.",
            f"Suggested name: {suggested}",
            f"Tier: {tier}",
        ]
        if bundle:
            doc_lines.append(f"Bundle: {', '.join(bundle)}")
        if rationale:
            doc_lines.append(f"Rationale: {rationale}")
        if fields:
            field_summary = []
            for field in fields:
                check_deadline()
                fname = field.name
                type_hint = field.type_hint
                field_summary.append(f"{fname}: {type_hint}")
            doc_lines.append("Fields: " + ", ".join(field_summary))
        if kind in {"dataclass", "protocol"}:
            lines.append('    """')
            for line in doc_lines:
                check_deadline()
                lines.append(f"    {line}")
            lines.append('    """')
            if not fields:
                lines.append("    pass")
            else:
                for field in fields:
                    check_deadline()
                    fname = field.name
                    type_hint = field.type_hint
                    lines.append(f"    {fname}: {type_hint}")
            lines.append("")
            continue

        lines.append(f"# Suggested ambient bundle: {suggested} (tier {tier})")
        if bundle:
            lines.append(f"# Bundle fields: {', '.join(bundle)}")
        if rationale:
            lines.append(f"# Rationale: {rationale}")
        if evidence:
            lines.append(f"# Evidence: {', '.join(evidence)}")
        unsupported = "control_context" not in set(evidence)
        if unsupported:
            lines.append(
                "# Advisory only: missing control_context evidence; keep this candidate as suggestion-only."
            )
        for field in fields:
            check_deadline()
            fname = field.name
            type_hint = field.type_hint
            identifier = _sanitize_contextvar_identifier(fname)
            contextvar_name = f"_{identifier}_context"
            lines.append(
                f"{contextvar_name}: ContextVar[{type_hint}] = ContextVar(\"{identifier}\")"
            )
            lines.append("")
            lines.append(
                f"def get_{identifier}(default: {type_hint}) -> {type_hint}:"
            )
            lines.append(
                f"    \"\"\"Read ambient `{fname}` from `{contextvar_name}`.\"\"\""
            )
            lines.append(
                f"    return _read_contextvar(\"{identifier}\", {contextvar_name}, default)"
            )
            lines.append("")
        lines.append("")
    return "\n".join(lines)
