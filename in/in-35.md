---
doc_revision: 1
reader_reintern: Reader-only: re-intern if doc_revision changed since you last read this doc.
doc_id: in_35
doc_role: in_step
doc_scope:
  - repo
  - analysis
  - semantics
  - tooling
doc_authority: normative
doc_owner: maintainer
doc_requires:
  - POLICY_SEED.md#policy_seed
  - glossary.md#contract
  - glossary.md#aspf
  - glossary.md#forest
  - CONTRIBUTING.md#contributing_contract
  - README.md#repo_contract
  - AGENTS.md#agent_obligations
  - in/in-30.md#in_in_30
doc_reviewed_as_of:
  POLICY_SEED.md#policy_seed: 1
  glossary.md#contract: 1
  glossary.md#aspf: 1
  glossary.md#forest: 1
  CONTRIBUTING.md#contributing_contract: 1
  README.md#repo_contract: 1
  AGENTS.md#agent_obligations: 1
  in/in-30.md#in_in_30: 4
doc_review_notes:
  POLICY_SEED.md#policy_seed: Reviewed policy constraints; no conflict.
  glossary.md#contract: Reviewed bundle semantics and commutation obligations.
  glossary.md#aspf: Reviewed carrier projection constraints.
  glossary.md#forest: Reviewed forest evidence model.
  CONTRIBUTING.md#contributing_contract: Workflow constraints unchanged.
  README.md#repo_contract: Scope and non-goals unchanged.
  AGENTS.md#agent_obligations: Agent obligations unchanged.
  in/in-30.md#in_in_30: Template reused.
doc_change_protocol: POLICY_SEED.md#change_protocol
doc_sections:
  in_in_35: 1
doc_section_requires:
  in_in_35:
    - POLICY_SEED.md#policy_seed
    - glossary.md#contract
    - in/in-30.md#in_in_30
doc_section_reviews:
  in_in_35:
    POLICY_SEED.md#policy_seed:
      dep_version: 1
      self_version_at_review: 1
      outcome: no_change
      note: "Execution-policy constraints preserved."
    glossary.md#contract:
      dep_version: 1
      self_version_at_review: 1
      outcome: no_change
      note: "Dataflow-bundle obligations preserved."
    in/in-30.md#in_in_30:
      dep_version: 4
      self_version_at_review: 1
      outcome: no_change
      note: "Template constraints adopted."
---

<a id="in_in_35"></a>

# in/in-35.md
## Broaden dict carrier tracking beyond literal subscript aliases

### Purpose
Increase dataflow precision for dict-based carriers by extending beyond strict `Name["literal"]` subscript forms while retaining conservative soundness.

### Non-goals
- No full symbolic execution for dictionary keys.
- No deep alias/points-to modeling of mutable container identity.
- No inference from arbitrary runtime-computed keys.

### Status
partial — alias/forward-use modeling is implemented with remaining refinements tracked.

Normative pointers: [POLICY_SEED.md#policy_seed](POLICY_SEED.md#policy_seed), [glossary.md#contract](glossary.md#contract), [in/in-30.md#in_in_30](in/in-30.md#in_in_30), [docs/sppf_checklist.md#in-35-dict-key-carrier-tracking](docs/sppf_checklist.md#in-35-dict-key-carrier-tracking).

### Implemented evidence
- Key functions (`src/gabion/analysis/dataflow_audit.py`): `_accumulate_function_index_for_tree`, `_unused_params`, `_analyze_unused_arg_flow_indexed`.
- Representative tests (`tests/`): `tests/test_unused_arg_audit.py::test_unused_arg_reports_unknown_key_carrier_category`, `tests/test_dataflow_audit_helpers.py::test_deserialize_param_use_filters_malformed_values`.

---

## Face / Kit / Solver

### Face (obligations)
- **F1:** Existing literal-key behavior must remain intact.
- **F2:** Additional key forms are supported only when deterministically recoverable.
- **F3:** Unknown key identity is represented explicitly as uncertainty, not silently collapsed.
- **F4:** No increase in unsound positive bundle claims.

### Kit (existing machinery)
- `src/gabion/analysis/visitors.py`
  - `UseVisitor.visit_Subscript`
  - alias maps (`_key_alias_to_param`, `_attr_alias_to_param`, `alias_to_param`)
- `src/gabion/analysis/dataflow_audit.py`
  - `ParamUse.non_forward` and bundle grouping/propagation

### Solver (implementation plan)
1. **Key-normalization helper**
   - Add utility to normalize supported key expressions into canonical key tokens.
   - Start with:
     - string literals,
     - constants bound to local names (`KEY = "x"; d[KEY]` in same scope),
     - conservative joined-string/static f-string forms if fully constant.

2. **Extend subscript handling**
   - Update `visit_Subscript` to use helper and map recoverable keys to alias-carried params.
   - Keep direct-load/direct-call behavior consistent with current forwarding logic.

3. **Introduce explicit uncertainty marker**
   - For non-recoverable key expressions, record a structured uncertainty marker (e.g., unknown-key usage) rather than only flipping `non_forward`.
   - Wire marker through existing reporting path with minimal schema churn.

4. **Preserve conservative propagation**
   - Only propagate dict-key-carried mappings when key identity is explicit and stable.

5. **Document supported key grammar**
   - Add brief developer docs/comments listing recognized key forms and explicit exclusions.

---

## Acceptance criteria

1. Existing literal-key tests continue to pass unchanged.
2. Name-bound key constants are recognized and forwarded where syntactically explicit.
3. Non-recoverable key expressions produce explicit uncertainty evidence.
4. No new false-positive bundles from dynamic key programs.
5. Report/lint output can distinguish “non-forward use” vs “unknown key carrier” where implemented.

---

## Test plan

- Extend tests near:
  - `tests/test_dataflow_dataclass_bundles.py`
  - `tests/test_dataflow_audit_coverage_gaps.py`
- Cases:
  - `k = "alpha"; sink(d[k])`
  - nested lookup with resolvable key constants
  - dynamic key function call `d[get_key()]` should remain conservative
  - mixed resolvable/unresolvable accesses in one function

---

## Risks and mitigations

- **Risk:** increased complexity in visitor alias state.
  - **Mitigation:** isolate key normalization logic and keep visitor branches small.
- **Risk:** accidental over-resolution of dynamic keys.
  - **Mitigation:** strict syntactic whitelist and explicit fallback marker.
