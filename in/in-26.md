---
doc_revision: 3
reader_reintern: "Reader-only: re-intern if doc_revision changed since you last read this doc."
doc_id: in_26
doc_role: in_step
doc_scope:
  - repo
  - tooling
  - research
  - semantics
doc_authority: normative
doc_requires:
  - POLICY_SEED.md
  - glossary.md
  - CONTRIBUTING.md
  - README.md
  - AGENTS.md
  - in/in-23.md
  - in/in-24.md
  - in/in-25.md
  - out/out-3.md
doc_reviewed_as_of:
  POLICY_SEED.md: 32
  glossary.md: 29
  CONTRIBUTING.md: 76
  README.md: 59
  AGENTS.md: 13
  in/in-23.md: 1
  in/in-24.md: 3
  in/in-25.md: 3
  out/out-3.md: 3
doc_review_notes:
  POLICY_SEED.md: "Reviewed POLICY_SEED.md rev32 (branch/tag CAS + check-before-use constraints); no conflicts with this document's scope."
  glossary.md: "Reviewed glossary rev29 (obsolescence projection path + self-review/mirror definitions); rewrite invariants unchanged."
  CONTRIBUTING.md: "Reviewed CONTRIBUTING.md rev76 (docflow audit now scans in/ by default); no conflicts with this document's scope."
  README.md: "Reviewed README.md rev59 (docflow audit now scans in/ by default); no conflicts with this document's scope."
  AGENTS.md: "Agent obligations unchanged; rewrite plan flow remains explicit."
  in/in-23.md: "Uses carrier/provenance artifacts as evidence."
  in/in-24.md: "Deadness evidence supplies acceptance predicates."
  in/in-25.md: "Coherence evidence supplies verification predicates."
  out/out-3.md: "Carrier hypothesis remains the foundation for proof-carrying rewrites."
doc_change_protocol: "POLICY_SEED.md §6"
doc_erasure:
  - formatting
  - typos
doc_owner: maintainer
---

# in/in-26.md

## Refactoring as Proof-Carrying Transformation

### From Evidence Artifacts to Verified Rewrite Plans

---

## 0. Status

**Scope: convert evidence into controlled action.**

* `in-23.md` establishes ASPF as an SPPF-equivalent **carrier**, plus reproducible synth bases and provenance artifacts.
* `in-24.md` adds **negative evidence** (deadness witnesses).
* `in-25.md` adds **higher positive evidence** (coherence witnesses / horn fillers).

This step makes those artifacts *operational*: it defines how the system may propose and apply refactorings **only** when the proposal is accompanied by sufficient evidence and is mechanically verifiable.

This is the first “write-back” step: the pipeline stops at reporting in 23–25; here we define a proof-carrying rewrite contract.

Normative pointers (explicit): `POLICY_SEED.md`, `glossary.md`, `CONTRIBUTING.md`, `README.md`, `AGENTS.md`, `in/in-23.md`, `in/in-24.md`, `in/in-25.md`, `out/out-3.md`.

---

## 1. Goal

Introduce a refactoring subsystem that:

* proposes concrete rewrites,
* attaches explicit evidence (provenance + deadness + coherence),
* and verifies that the rewrite preserves semantic invariants by re-auditing.

Equivalently:

> A rewrite is admissible iff it is accompanied by a witness bundle and passes a re-audit that re-establishes the same boundary semantics.

This step deliberately avoids “global solver magic.” It is local, auditable, and artifact-driven.

---

## 2. Definitions (minimal, repo-native)

### 2.1 RewritePlan (proof-carrying refactor proposal)

A **RewritePlan** is a structured proposal to transform code while preserving semantics.

Normative fields:

* `plan_id`: stable identifier
* `site`: `(path, function, bundle)` (surface anchor)
* `pre`: boundary evidence before rewrite

  * base/ctor keys
  * synth version / basis identity if relevant
  * glossary match set
  * remainder (must be empty or explicitly justified)
* `rewrite`: the proposed transformation

  * rewrite kind (enum)
  * target span/selector (not necessarily byte offsets; repo-native selectors allowed)
  * parameters (e.g., rename target, ctor rewrite, contextvar rewrite)
* `evidence`: witness bundle

  * provenance entry reference(s)
  * coherence witness reference(s) if ambiguity exists
  * deadness witness reference(s) for pruned alternatives (optional but must be explicit)
* `post_expectation`: what must remain invariant

  * base conservation target
  * ctor coherence target
  * match strata target (exact/base-only/none)
* `verification`: how success is checked

  * re-audit command spec
  * required artifact equality predicates (see §6)

### 2.2 RewriteKind (initial minimal set)

The system should begin with a minimal set of rewrite kinds that correspond to already-detected issues:

* `CTOR_NORMALIZE`: normalize ctor spellings / representations to match ctor carrier expectations
* `BUNDLE_ALIGN`: rename/restructure bundle parameters to match glossary carriers (name-level refactor)
* `SURFACE_CANONICALIZE`: rewrite type spellings to canonical type keys where safe
* `AMBIENT_REWRITE`: contextvar/ambient rewrite suggestion (from earlier decision-surface work)
  *(Only if prior steps already produce suggestions; otherwise keep as placeholder)*

This list is intentionally narrow; any additional rewrite kind must come with its own invariants and tests.

### 2.3 RewritePlan artifact

`fingerprint_rewrite_plans.json` is the serialized list of RewritePlan entries.

This is the “actionable sibling” to:

* `fingerprint_provenance.json` (boundary evidence)
* `fingerprint_deadness.json` (emptiness evidence)
* `fingerprint_coherence.json` (branch/coherence evidence)
* `fingerprint_synth.json` (basis)

---

## 3. Principle: no rewrite without a witness bundle

A rewrite is never justified by “it seems safe.”

It is justified by:

* boundary equivalence evidence (provenance),
* ambiguity accounting (coherence), and
* emptiness accounting (deadness), when applicable.

This enforces the “attribute grammar” stance operationally:

* a rewrite is a transformation of derivations under constraints,
* and the constraints must be explicit.

---

## 4. Face / Kit / Solver (repo idiom)

### 4.1 Face (obligations)

**R1 — Evidence-backed proposals**
Every proposed rewrite must include a witness bundle linking it to observed provenance/coherence/deadness artifacts.

**R2 — Conservative applicability**
If evidence is `UNKNOWN` or has remainder, the plan must either:

* refuse to propose a rewrite, or
* explicitly mark the plan `UNVERIFIED` and require manual review.

**R3 — Verification by re-audit**
A plan is “accepted” only if executing it and re-running the audit yields the expected invariants (defined below).

**R4 — Determinism and diffability**
Rewrite plans must be deterministic across runs (stable ordering, stable plan IDs), and diffable in snapshots.

**R5 — Non-destructive traceability**
Plans must refer to stable selectors; if selectors are ambiguous, that must be explicit.

**R6 — No silent widening**
A rewrite may not widen semantic equivalence classes. If base/ctor carriers change, that must be flagged as a semantic change, not a refactor.

### 4.2 Kit (available machinery)

Already established by 23–25:

* boundary evidence: provenance entries (base/ctor keys + matches + remainder)
* negative evidence: deadness witnesses
* higher evidence: coherence witnesses (fork signatures + frack paths)
* deterministic synth basis (save/load) and pinned snapshot artifacts
* CLI/LSP/report plumbing patterns + snapshot integration practice
* re-audit tooling (dataflow-audit + docflow)

### 4.3 Solver (how obligations are discharged)

The solver operates in two phases:

#### Phase A — Synthesis of RewritePlan candidates (read-only)

Input: evidence artifacts from `in-23..25`.

Process:

1. Identify **refactor targets** by mismatch strata:

   * base matches glossary but ctor differs → candidate `CTOR_NORMALIZE`
   * base+ctor match exists but surface names misalign → candidate `BUNDLE_ALIGN`
   * canonicalization mismatch where types are equivalent under carrier → candidate `SURFACE_CANONICALIZE`
2. For each target, attach:

   * the provenance entry (mandatory)
   * coherence witness if multiple alternatives exist (mandatory in ambiguous cases)
   * deadness witness if a branch is being discarded (mandatory when used)
3. Emit:

   * report section: **Rewrite plans**
   * JSON: `fingerprint_rewrite_plans.json`

No code is modified in Phase A.

#### Phase B — Verification (write-back guarded by re-audit)

A plan can be applied only via a guarded workflow:

1. apply rewrite (manual or tool-mediated; this step defines the contract, not the editor)
2. re-run audit with pinned basis artifacts (synth/provenance/deadness/coherence as applicable)
3. check acceptance predicates (§6)
4. snapshot results and retain both pre/post artifacts for diff

---

## 5. Artifact contract

### 5.1 Required artifact (when enabled)

* `fingerprint_rewrite_plans.json`
* report section: **Rewrite plans**
* LSP field: `fingerprint_rewrite_plans` (or equivalent)

### 5.2 Plan schema obligations

Each plan must include:

* stable `plan_id`
* `site` anchor
* `pre` boundary evidence (including remainder)
* `rewrite` specification (kind + selector)
* `evidence` references (by stable keys, not raw line numbers)
* `post_expectation` invariants
* `verification` command spec (or named verification mode)

Ordering:

* sort by `(path, function, bundle, rewrite.kind, plan_id)`.

---

## 6. Verification predicates (normative)

A rewrite plan is **accepted** only if the following hold in a re-audit:

**V1 — Base conservation**

* base carrier keys/products equal (or equal under rehydration via same basis)

**V2 — Constructor coherence**

* ctor carrier keys/products equal (unless the rewrite kind is explicitly ctor-normalizing; in that case, ctor carrier must match the glossary target)

**V3 — Match strata preservation**

* if pre-state had an exact match, post-state must have an exact match
* if pre-state had base-only match (ctor mismatch), post-state may improve to exact, but must not degrade to none

**V4 — Remainder non-regression**

* remainder must not increase; ideally it must decrease or remain zero

**V5 — Deadness and coherence consistency**

* any deadness claims used to justify pruning remain valid under the new code
* any coherence witness relied upon remains constructible or is superseded by strengthened determinism (explicitly recorded)

**V6 — Deterministic artifacts**

* post-run artifacts are deterministic and snapshot-captured

If any predicate fails, the plan is rejected; failure is recorded explicitly.

---

## 7. Snapshot integration (required)

Extend snapshot tooling to capture rewrite plans:

* `audit_snapshot.sh` captures `fingerprint_rewrite_plans.json` when enabled
* `latest_snapshot.sh` adds selector `--fingerprint-rewrite-plans`
* snapshots should preserve pre/post plan execution runs as separate snapshots (or a paired snapshot record)

---

## 8. Checks as lemmas (tests → obligations)

Introduce tests analogous to earlier steps:

* **Plan generation test** (R1/R2):

  * for a known mismatch scenario, ensure exactly one deterministic plan is emitted with proper evidence links

* **Plan determinism test** (R4):

  * same inputs yield byte-identical `fingerprint_rewrite_plans.json`

* **Verification predicate test (simulated)** (R3/V*):

  * on a tiny fixture, apply a rewrite mechanically and assert post-run invariants match expectations
    *(If full apply is heavy, provide a “mock apply” and verify the acceptance predicate logic itself.)*

Acceptance mapping: see `docs/matrix_acceptance.md` for the minimum test suite
and schema obligations derived from the 3×3×3 matrix.

Docflow audit remains required.

---

## 9. Relation to attribute grammar and ∞-groupoid view (contract-level)

This step turns “rewriting” into a proof-carrying operation:

* a rewrite plan is a 1-cell candidate,
* coherence and deadness artifacts constrain which 1-cells exist,
* verification predicates enforce that the rewrite inhabits the same semantic fiber.

Operationally:

* we do not require global coherence closure,
* we require locally witnessed coherence sufficient to justify the rewrite.

This is the minimum discipline needed before any automated multi-step path search.

---

## 10. Minimal success criteria

This step is complete when:

1. `fingerprint_rewrite_plans.json` is emitted, deterministic, and snapshot-captured.
2. Each plan references evidence artifacts (provenance/coherence/deadness) and states post expectations.
3. A verification workflow exists: apply → re-audit → accept/reject with explicit predicates.
4. No plan is accepted without passing re-audit invariants.

---

## 11. Homology of this document (explicit self-audit)

This step extends the previous chain complex by adding “action” as a new chain level:

* **C₀**: boundary objects (carriers, basis, environments)
* **C₁**: derivation alternatives and constraints (provenance, deadness, coherence)
* **C₂**: coherence fillers (witnesses)
* **C₃**: rewrite plans (proposed 1-cells with evidence)
* **∂**: verification predicates + re-audit act as the boundary map from “plan” back to “invariants”
* **H₃**: accepted rewrites: cycles that close under ∂ (plans whose boundaries vanish under invariants)

“holes” correspond to rewrites that appear plausible but cannot be closed under verification; these must remain rejected and explicit.

---

## 12. Orthogonal implication braid (3×3×3, concise)

### N₁ RewritePlan

* I₁.1 **Soundness**: plan preserves semantics when accepted

  * I₁.1.a base invariants preserved
  * I₁.1.b ctor invariants preserved or improved toward glossary target
  * I₁.1.c remainder does not grow
* I₁.2 **Explainability**: plan is justified, not guessed

  * I₁.2.a provenance entry anchors boundary
  * I₁.2.b coherence/deadness references justify alternative handling
  * I₁.2.c post_expectation is explicit
* I₁.3 **Reproducibility**: plan is stable and diffable

  * I₁.3.a deterministic IDs and ordering
  * I₁.3.b snapshot capture
  * I₁.3.c basis pinning

### N₂ Verification

* I₂.1 **Closure**: acceptance is a closed-loop check

  * I₂.1.a apply → re-audit → predicates
  * I₂.1.b accept/reject recorded explicitly
  * I₂.1.c failures surfaced with diagnostics
* I₂.2 **Locality**: verification is site-scoped

  * I₂.2.a selector stability
  * I₂.2.b avoids global inference
  * I₂.2.c isolates regressions
* I₂.3 **Non-widening**: refactors do not widen meaning

  * I₂.3.a match strata non-degradation
  * I₂.3.b basis stability
  * I₂.3.c explicit semantic change classification if violated

### N₃ Tooling integration

* I₃.1 **CLI/LSP parity**: same plans everywhere

  * I₃.1.a consistent JSON fields
  * I₃.1.b stable rendering in reports
  * I₃.1.c selectors are stable
* I₃.2 **Snapshot discipline**: evidence survives time

  * I₃.2.a artifacts captured
  * I₃.2.b pre/post runs preserved
  * I₃.2.c diffs meaningful due to determinism
* I₃.3 **Audit semantics**: plans are obligations

  * I₃.3.a missing evidence blocks plan emission
  * I₃.3.b UNKNOWN evidence blocks acceptance
  * I₃.3.c verification failures are first-class outcomes

---

## 13. Commands (reference)

### Local checks

* `python -m pytest -q`
* `mise exec -- python scripts/docflow_audit.py --root .`

### Emit rewrite plans

* `gabion dataflow-audit --fingerprint-rewrite-plans-json <path> ...`

### Apply + verify (conceptual contract)

* apply edit (manual/tool)
* `gabion dataflow-audit ...` with pinned basis artifacts
* compare artifacts/predicates per §6

### Snapshot capture

* `./audit_snapshot.sh`
* `./latest_snapshot.sh --fingerprint-rewrite-plans`

(Flags must match repo CLI; this section is normative and must be kept aligned with implementation.)

---

## 14. Closing

`in-26` is the point where evidence becomes action:

* `in-23` provides carriers and provenance,
* `in-24` provides deadness,
* `in-25` provides coherence,
* `in-26` uses them to produce **proof-carrying rewrite plans** whose acceptance is determined by re-audit invariants.

This step is the minimal foundation required before attempting:

* automated multi-step rewrite search,
* equivalence-class merging (e-graph style),
* and explicit dimension genesis beyond `synth@k`.
