---
doc_revision: 1
reader_reintern: "Reader-only: re-intern if doc_revision changed since you last read this doc."
doc_id: in_23
doc_role: in_step
doc_scope:
  - repo
  - tooling
  - research
  - semantics
doc_authority: normative
doc_requires:
  - POLICY_SEED.md
  - glossary.md
  - CONTRIBUTING.md
  - README.md
doc_reviewed_as_of:
  POLICY_SEED.md: 28
  glossary.md: 19
  CONTRIBUTING.md: 71
  README.md: 58
doc_change_protocol: "POLICY_SEED.md §6"
doc_erasure:
  - formatting
  - typos
doc_owner: maintainer
---

# in/in-23.md

## ASPF Carrier Formalization as Attribute-Grammar Evidence

### Provenance + Synth Basis as Reproducible Audit Artifacts

---

## Status

**Implemented-in-part (pipeline + artifacts exist); formalization pass.**
This step consolidates the already-implemented ASPF/SPPF machinery into a single, repo-native, audit-grade specification whose outputs are **artifacts** (not interpretations).

This document is intentionally **operational**: it defines obligations, artifacts, and checks. It does not add a new mechanism; it binds existing mechanisms to a coherent contract.

---

## 1. Goal

Establish the ASPF carrier as a **first-class semantic object** whose behavior is:

* **deterministic**,
* **serializable**,
* **reloadable**,
* **auditable in snapshots**, and
* **explainable at the surface interface** (CLI + LSP + report),

such that:

> ASPF fingerprints and their provenance are sufficient to treat matches/mismatches as **structured derivation evidence** (SPPF-equivalent), rather than as heuristic signals.

This step is also the point where the “grammar inducer” is treated explicitly as an **attribute-grammar inducer**:
the system computes *both* derivational structure (packed alternatives) *and* attribute flow constraints (e.g., constant propagation / deadness), and emits evidence for both.

---

## 2. Definitions (repo-native, minimal)

### 2.1 Carriers and dimensions

A **Fingerprint** is a mapping from **Dimension → Carrier**, where a **Carrier** is:

* an exact multiset representation (prime product), and
* a bitmask representation (presence/powerset carrier).

Dimensions currently used:

* `base`: canonical atomic semantics
* `ctor`: constructor carriers (structural operators)
* `synth@k`: synthesized atoms with reversible tails (basis is versioned)
* `prov`: provenance (derivational origin / path evidence)

The carrier is semantic-authoritative in its **prime product** component; the **bitmask** component is a necessary filter, not a proof.

### 2.2 Provenance entries (surface projection)

A **fingerprint provenance entry** is the unit of surface projection:

* `path`
* `function`
* `bundle` (the parameter set or equivalent site key)
* `base_keys`
* `ctor_keys`
* `glossary_matches`
* `remainder` (non-rehydratable residue; must be explicit)

These entries are emitted as:

* report sections (human readable), and
* `fingerprint_provenance.json` (machine readable, snapshot stable).

### 2.3 Synth registry (basis)

A **synth registry** is the frozen vocabulary/basis for a synth epoch:

* version tag (`synth@k`)
* deterministic assignment
* reversible tails (tail map is canonical)
* serializable payload
* reloadable basis used across runs

This registry is emitted as:

* report section (“Fingerprint synthesis”), and
* `fingerprint_synth.json` (machine readable, snapshot stable).

---

## 3. Thesis refinement (why this is an attribute grammar)

A “non-attribute grammar” is indistinguishable from an attribute grammar with all free variables eliminated.
In practice: whenever a system computes *any* semantic invariant (synthesized attribute) or propagates constraints (inherited attribute), it is already in the attribute-grammar regime.

This codebase has crossed that threshold by construction:

* **Synthesized attributes**: base/ctor/synth fingerprints, glossary match sets, remainders
* **Inherited attributes**: constraint propagation contexts (e.g., constant propagation), which determine reachability and deadness

Therefore:

* packed derivations correspond to **multiple valid attribute assignments** (branch witnesses), and
* dead branches correspond to **unsatisfiable attribute constraints** (empty inhabitance / “no derivation exists”).

This step does **not** require that every coherence move be explicitly stored. Instead:

* universal coherence of composition is treated as “free completion,” while
* domain-meaningful bifurcation evidence is surfaced explicitly by iterative “fracking” from internal branch points to the surface interface.

---

## 4. Face / Kit / Solver (repo idiom)

### 4.1 Face (obligations)

The pipeline must discharge the following obligations via artifacts and checks.

**F1 — Determinism**
Prime/bit assignments and synth atom assignments must be deterministic and stable across runs, given the same basis and inputs.

**F2 — Conservation (base)**
Valid refactorings and derivation alternatives preserve the base carrier (exact multiset semantics).

**F3 — Constructor coherence**
Ctor carriers contribute to the match key and cannot be silently erased by canonicalization.

**F4 — Synth tail reversibility**
Every synth atom must have a canonical tail; rehydration must be total for all basis atoms. Any remainder must be explicit.

**F5 — Carrier soundness**
Bitmask claims must never contradict prime-product claims (e.g., disjoint mask implies gcd==1; overlap is necessary but not sufficient).

**F6 — Provenance completeness (surface projection)**
Every surfaced match/warning must be explainable via provenance entries including base/ctor keys, glossary matches, and remainder.

**F7 — Snapshot reproducibility**
Audit snapshots must capture the synth basis and provenance artifacts such that later runs can reproduce the same semantic interpretation.

### 4.2 Kit (available machinery)

Already implemented in the repo (as of this step):

* dimensional fingerprints (base + ctor)
* glossary matching keyed by dimensional carriers
* synth registries (`synth@k`) with deterministic assignment + tail mapping
* synth registry serialization and reload (`*_payload` / `*_from_payload`)
* provenance JSON artifact (`fingerprint_provenance.json`)
* synth JSON artifact (`fingerprint_synth.json`)
* report sections for synthesis and provenance
* snapshot integration via `audit_snapshot.sh` and `latest_snapshot.sh`
* docflow audit enforcing documentation hygiene

### 4.3 Solver (how obligations are discharged)

The solver is the existing audit pipeline:

* `dataflow_audit.py` produces report + artifacts
* CLI and LSP surface the artifacts end-to-end
* snapshots persist artifacts and expose them via `latest_snapshot.sh`

The “fracking” process is operationalized as:

* detect internal branching (multiple derivations / mismatches / remainder)
* project it upward into `fingerprint_provenance` entries
* preserve the minimal bifurcation witness necessary for surface explanation
* iterate until the surface interface has sufficient evidence

This is the intended implementation style: evidence is discovered and lifted, not postulated.

---

## 5. Artifact contract

### 5.1 Required files (when enabled)

When synthesis and provenance are enabled/configured, the run must be able to produce:

* `fingerprint_synth.json`
* `fingerprint_provenance.json`

and include corresponding human-readable report sections.

### 5.2 Snapshot integration (required)

Audit snapshots must include:

* synth registry artifact
* provenance artifact
* stable listing via `latest_snapshot.sh` selectors

“LATEST” resolution must not be a semantic ambiguity: it must be recorded (path, version, and/or basis hash) in report/artifact metadata or an adjacent snapshot note, so that a run is explainable after the fact.

---

## 6. Configuration contract

### 6.1 Minimal config knobs (current)

* `fingerprints.synth_version = "synth@k"` (required for deterministic epochs)
* `fingerprints.synth_min_occurrences` (policy knob; if set to 1 this becomes “fold everything observed”)
* `fingerprints.synth_registry_path` with `LATEST` resolution (basis loading)

### 6.2 Policy note: “fold everything”

If the repo policy is “compute is cheap, memory is not,” then the correct framing is:

* synthesis is not a frequency heuristic,
* it is deterministic interning of all observed composites under a frozen basis.

In that mode, the correctness burden shifts to:

* canonical tail normalization
* basis stability and versioning
* remainder reporting for anything not representable

This step establishes the infrastructure needed for that mode (loadable basis + artifacts + snapshot capture), even if the synthesis decision policy remains adjustable.

---

## 7. Checks as lemmas (tests → obligations)

This repo treats tests as executable lemmas. The following mapping is normative.

* `test_type_fingerprints.py` discharges:

  * F1 Determinism (registry seeding; stable ctor atoms)
  * F4 Synth tail reversibility (round-trip payload load/save)
  * F5 Carrier soundness (mask/product alignment checks)

* `test_fingerprint_warnings.py` discharges:

  * F6 Provenance completeness (entries include base/ctor keys + glossary match)
  * F4 Remainder explicitness (where applicable)
  * F7 Artifact emission (JSON payload exists when requested)

* `scripts/docflow_audit.py --root .` discharges:

  * documentation hygiene constraints (doc_revision propagation and checklist coherence)
  * ensures the audit pipeline remains internally self-describing

---

## 8. Minimal Success Criteria (this step)

This step is complete when:

1. **Provenance is an artifact**
   `fingerprint_provenance.json` exists, is snapshot-captured, and is surfaced via CLI + LSP.

2. **Synth basis is reproducible**
   `fingerprint_synth.json` exists, is snapshot-captured, and can be reloaded to reproduce synthesis reporting across runs.

3. **Determinism is enforced**
   CI asserts stable prime/bit assignment and stable synth assignment under a given basis.

4. **Remainders never vanish**
   Any unrehydratable residue is surfaced (report + JSON), never silently ignored.

If these hold, ASPF carrier semantics are no longer a hypothesis: they are a reproducible, auditable contract.

---

## 9. Known gaps / next passes (intentionally scoped)

This step does **not** require the following, but it prepares their foundation:

* **Match strata** (exact vs base-only vs none) as first-class reporting
* **Strict vs extend basis mode** (default strict is metalogically cleaner)
* **Coherence move enumeration** beyond surfaced bifurcation witnesses
* **Deadness artifacts** (constant propagation proofs of emptiness) surfaced analogously to provenance
* **Cayley–Dickson dimension genesis** (explicit dimension-fork metadata; basis parent pointers)

---

## 10. Homology / “structure of this document” (explicit self-audit)

This document is organized as a chain complex of obligations and witnesses:

* **C₀ (Objects)**: Fingerprints, Registries, Provenance Entries
* **C₁ (Morphisms)**: CLI/LSP/report/snapshot transport of artifacts
* **∂ (Boundary map)**: Tests and docflow map artifacts back to obligations
* **H₀**: The stable semantic carrier classes established by determinism and conservation
* **H₁**: The audit-time equivalence evidence (provenance entries as 1-cycles of explanation)
* **Higher homology**: deferred (coherence moves, deadness proofs, CD steps)

This is not decorative: the repo’s practice is to treat artifacts + tests as the canonical witnesses. The “homology” here is precisely “what remains invariant under the boundary checks.”

---

## 11. Orthogonal implication braid (3×3×3, concise)

For each primary notion below, we state three congruent implications that are mutually orthogonal (i.e., they constrain different failure modes). Each is then expanded twice (second- and third-order), preserving orthogonality. This is a compact “coverage braid,” not an essay.

### N₁ Determinism

* I₁.1 **Reproducibility**: same inputs+basis ⇒ identical artifacts

  * I₁.1.a snapshot diffs reflect semantic change, not ordering noise
  * I₁.1.b LSP/CLI parity (same run yields same registry/provenance)
  * I₁.1.c basis hash/pin makes “LATEST” non-ambiguous
* I₁.2 **Comparability**: outputs are meaningful under diff

  * I₁.2.a stable key ordering in JSON prevents false churn
  * I₁.2.b stable synth IDs preserve long-term interpretability
  * I₁.2.c deterministic tail canonicalization avoids alias drift
* I₁.3 **Audit integrity**: failure is detectable, not latent

  * I₁.3.a nondeterminism must trip tests
  * I₁.3.b remainder must surface, never disappear
  * I₁.3.c schema/version mismatches must be loud

### N₂ Conservation (base)

* I₂.1 **Refactor invariance**: valid rewrites preserve base carrier

  * I₂.1.a match strata can be defined relative to base invariance
  * I₂.1.b provenance provides witness of preservation site-wise
  * I₂.1.c synth folding cannot alter base rehydration result
* I₂.2 **Equivalence class stability**: semantics partitions are stable

  * I₂.2.a packed alternatives live inside a base fiber
  * I₂.2.b deadness is emptiness of a fiber region (future artifact)
  * I₂.2.c glossary entries can target base meaning independent of syntax
* I₂.3 **Error localization**: violations point to specific edges

  * I₂.3.a remainders identify missing basis or canonicalization gaps
  * I₂.3.b mismatched ctor keys isolate structural divergence
  * I₂.3.c provenance links isolate which bundle broke conservation

### N₃ Provenance (surface projection)

* I₃.1 **Explainability**: every warning/match has a witness

  * I₃.1.a JSON is the minimal reifiable witness set
  * I₃.1.b report is a projection of JSON, not separate truth
  * I₃.1.c snapshot capture makes witnesses durable
* I₃.2 **SPPF mapping hooks**: derivation evidence is concrete

  * I₃.2.a base/ctor keys are terminal/nonterminal boundary evidence
  * I₃.2.b remainder is the explicit “unfilled horn” marker
  * I₃.2.c synth tails provide packed-node expansion handles
* I₃.3 **Tooling integration**: evidence is accessible where needed

  * I₃.3.a LSP carries provenance for IDE-time inspection
  * I₃.3.b CLI emits artifacts for CI and snapshotting
  * I₃.3.c latest_snapshot selectors reduce operator error

(End braid; deeper expansion is intentionally deferred to the next in-doc to avoid turning coverage into verbosity.)

---

## 12. Commands (reference)

### Local correctness checks

* `python -m pytest -q`
* `mise exec -- python scripts/docflow_audit.py --root .`

### Audit run with artifacts

* `gabion dataflow-audit --fingerprint-synth-json <path> --fingerprint-provenance-json <path> ...`

### Snapshot capture

* `./audit_snapshot.sh`
* `./latest_snapshot.sh --fingerprint-synth`
* `./latest_snapshot.sh --fingerprint-provenance`

(Exact flags should match the repo’s current CLI; this section is normative in intent but must remain mechanically aligned with the current implementation.)

---

## 13. Closing

This step formalizes what is already true in the system:

* ASPF is a semantic carrier, not a hash.
* Provenance and synth basis are first-class artifacts.
* Determinism, conservation, and reversibility are enforced by tests and snapshotting.
* Branching and deadness are attribute-level facts; surface projection is a witness discipline.

With this step complete, future work can safely extend toward:

* explicit coherence move libraries,
* deadness witnesses as artifacts,
* and dimension genesis (CD steps) as versioned basis forks—without losing auditability.
