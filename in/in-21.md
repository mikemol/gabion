---
doc_revision: 1
reader_reintern: "Reader-only: re-intern if doc_revision changed since you last read this doc."
doc_id: in_21
doc_role: inbox
doc_scope:
  - repo
  - inbox
doc_authority: informative
doc_owner: maintainer
doc_requires:
doc_reviewed_as_of:
doc_review_notes:
doc_change_protocol: "POLICY_SEED.md §6"
doc_erasure:
  - formatting
  - typos
---
Here is the reconstructed document in Markdown. I have replaced the missing image placeholders with the appropriate **LaTeX** mathematical notation to restore the flow of the text.

Per your request for **Agda** and **Python** representations, I have integrated them as follows:

* **LaTeX**: Used for all inline formulas and theoretical descriptions within the document body.
* **Python**: Used in the "Implementation Strategy" sections to concretize the logic.
* **Agda**: Added as a formal "Appendix" to rigorously define the algebraic isomorphism and ring operations described in the theory section.

---

# Semantic Factorization and Prime-Labeled Grammar Compression

**An Algebraic Framework for Architectural Linting**

### 1. Executive Summary

The evolution of static analysis has progressively moved from syntactic pattern matching to semantic graph analysis. **Gabion**, as an architectural linter, occupies a critical niche in this trajectory by identifying "data clumps"—implicit groups of parameters that travel together through a system. However, the current structural representation of these bundles relies on literal or set-based matching, which is computationally expensive ( for global deduplication), sensitive to ordering noise, and algebraically opaque.

This report presents a comprehensive theoretical and technical specification for "Prime-Labeled Grammar Compression," a paradigm shift that redefines type systems as algebraic rings. By mapping primitive types to prime numbers (or positions in a bit-vector space) and composite types to their products, we achieve a canonical, order-independent representation of data structures.

This isomorphism allows architectural analysis to be performed via "Structural Arithmetic":

* **Bundle Deduplication** becomes **Integer Equality** ().
* **Common Substructure** detection becomes **Greatest Common Divisor** ().
* **Union typing** becomes **Least Common Multiple** ().
* **Subtyping** becomes **Modular Arithmetic** ().

This report rigorously evaluates this proposal, exploring the tension between Integer Product encodings (which preserve multiplicity) and Prime-Position Bitmasks (which optimize for speed), ultimately proposing a hybrid architecture that integrates seamlessly with Gabion’s existing Language Server Protocol (LSP) and LibCST foundations.

---

### 2. Contextual Analysis: The Architecture of Implicit Dataflow

#### 2.1. The "Data Clump" Pathology in Python

In large-scale Python development, architectural entropy often manifests as "Data Clumps." These are recurring clusters of primitive parameters—such as `(user_id, merchant_id, timestamp)`—that are passed identically across multiple service layers. While syntactically valid, these clumps represent a failure of abstraction. They function as "ghost objects," possessing identity and cohesion but lacking explicit structural definition.

#### 2.2. Limitations of the Current Structural Representation

The current implementation of Gabion represents these bundles as Pydantic models containing lists of parameter metadata. This representation is literal and symbolic, leading to several deficiencies in large-scale analysis:

1. **Combinatorial Comparison Costs**: Determining if Bundle A is a subset of Bundle B requires iterating through their constituent sets. In a codebase with  functions, detecting global overlap requires  (approx ) pairwise comparisons, heavily burdened by set intersection logic.
2. **Order Sensitivity**: A function signature `f(a: int, b: str)` is structurally distinct from `g(b: str, a: int)` in a naive AST representation. Normalization requires lexicographical sorting, adding  overhead per signature (where  is the parameter count).
3. **Semantic Opacity**: There is no algebraic way to assert that a `UserContext` defined in the glossary is mathematically equivalent to the detected bundle in `auth.py`.

The proposed solution addresses these limitations by mapping the "Grammar Space" of types to the "Number Space" of arithmetic.

---

### 3. Theoretical Framework: The Algebra of Types

The core premise of Prime-Labeled Grammar Compression is that the composition of data types can be modeled as operations in a commutative ring.

#### 3.1. The Fundamental Isomorphism

The **Fundamental Theorem of Arithmetic (FTA)** states that every integer  is either a prime or a unique product of primes. This theorem allows us to construct an isomorphism  between the set of all possible composite types  and the set of positive integers .

Let  be the set of prime numbers.
Let  be the set of primitive types.

We define a mapping function  such that every primitive type corresponds to a unique prime. A composite type (a parameter bundle) is defined as a multiset of primitives.

The **fingerprint** of a bundle  is the product of the mapped primes:


This encoding has three critical properties derived from Ring Theory:

1. **Uniqueness**: By the FTA, no two distinct multisets of primes produce the same integer product. Thus, every unique bundle structure has a unique integer fingerprint.
2. **Commutativity**: Multiplication is commutative (). Therefore, the bundle `(int, str)` () has the identical fingerprint to `(str, int)` (). This automatically solves the order sensitivity problem without sorting.
3. **Reversibility**: Given an integer , one can perform prime factorization to perfectly reconstruct the constituent types (the multiset).

#### 3.2. Multisets vs. Sets: The Bitmask Controversy

The original request suggests treating primes as "positions in a bitmask against the set of all primes." This introduces a fundamental architectural trade-off between **Set Theory** and **Multiset Theory**.

**3.2.1. The Bitmask (Set) Model**

* **Representation**: A bit-vector .
* **Composition**: Bitwise OR ().
* **Intersection**: Bitwise AND ().
* **Difference**: Bitwise XOR ().
* **Limitation**: Bitmasks are idempotent (). A bundle `{int, int}` has the same signature as `{int}`. This destroys multiplicity information required for refactoring.

**3.2.2. The Integer Product (Multiset) Model**

* **Representation**: Arbitrary-precision integer .
* **Composition**: Multiplication ().
* **Intersection**: Greatest Common Divisor ().
* **Difference**: Division ( or ).
* **Advantages**: Preserves multiplicity. , while .

**Synthesis**: We assume the **Integer Product Model** as the primary implementation due to algebraic robustness, while retaining the "Bitmask" concept for simplified "existence checks" in the CI audit phase.

#### 3.3. Nested Structures and Dimensionality

To handle nested types (e.g., `List[int]`), we introduce **Dimensional Prime Mapping**. We treat type constructors (e.g., `List`) not as primes themselves, but as dimension operators.

* **Recursive Prime Assignment**: `List[int]` is treated as a unique structural atom.
* The analyzer queries the registry for the symbol `List[int]`. If unassigned, a new prime is allocated (e.g., ).
* A bundle `(List[int], int)` becomes .

---

### 4. Implementation Strategy: The Structural Arithmetic Engine

#### 4.1. The Prime Registry Architecture

The PrimeRegistry maintains a map between Type Structures and Prime Numbers.

**Table 1: Example Prime Registry State**
| Canonical Type Key | Assigned Prime () | Semantics |
| :--- | :--- | :--- |
| `builtins.int` | 2 | Primitive Integer |
| `builtins.str` | 3 | Primitive String |
| `builtins.bool` | 5 | Primitive Boolean |
| `typing.Any` | 7 | Dynamic Type |
| `typing.List[builtins.int]` | 11 | List of Integers |

#### 4.2. Encoding Type Expressions (Python Logic)

The encoding process traverses the function signature in the CST.

```python
# Conceptual Python Implementation
def compute_signature_fingerprint(params: List[Param]) -> int:
    fingerprint = 1
    for param in params:
        # 1. Canonicalize type string (e.g., "List[ int ]" -> "typing.List[builtins.int]")
        type_key = canonicalize(param.annotation)
        
        # 2. Recursive Prime Assignment
        # If type_key not in registry, assign next_prime()
        prime = registry.get_or_assign(type_key)
        
        # 3. Accumulate Product
        fingerprint *= prime
    return fingerprint

```

**Example Trace**:

* `user_id: int`  Prime 2. Accumulator .
* `username: str`  Prime 3. Accumulator .
* `flags: List[int]`  Prime 11. Accumulator .
* **Result**: 66.

#### 4.3. The Canonical Operations (Structural Arithmetic)

**4.3.1. GCD: Common Substructure Detection**
Computes the intersection of bundles.

* **Scenario**: Bundle A (`{int, str, List[int]}` ) vs Bundle B (`{int, str}` ).
* **Operation**: .
* **Result**: The integer 6 represents the shared structure `{int, str}`.

**4.3.2. LCM: Composite Expressions**
Computes the union of bundles (deduplicating shared elements by taking max multiplicity).

* **Scenario**: Merge `{int}` () and `{str}` ().
* **Operation**: .

**4.3.3. Modulo: Subtyping and Subsumption**
Checks for containment.

* **Scenario**: Can Function A accept Bundle B?
* **Operation**: `if F_A % F_B == 0:`
* **Result**: If the remainder is 0, Bundle B is a strict subset of Function A.

**4.3.4. XOR: Structural Difference**
The "symmetric difference" (elements in A or B but not both).

* **Formula**: In the integer domain, the equivalent of symmetric difference is:


* **Result**: This gives the product of non-shared factors.

---

### 5. Integrating Semantic Governance

The glossary becomes a **Registry of Semantic Primes**.

**Example Flow**:

1. User defines `user_context = { user_id="int", username="str" }`.
2. Gabion computes .
3. **Automated Audit**:
* **Exact Match**: Fingerprint is exactly 6.
* **Containment**: Fingerprint is divisible by 6 ().


4. This check is orders of magnitude faster than AST traversal.

---

### 6. Synthesis and Refactoring

To generate code, we must "Reverse the Hash" (Factorization).

* **Factorization**: Given , factors are .
* **Reconstruction**: Map , .
* **Name Recovery**: Gabion retrieves parameter names from the original source locations associated with these primes to generate the `dataclass`.

---

### 7. Performance and Bitmask Optimization

To satisfy the request for "cheaper computation," we propose a **Hybrid Solution**.

1. **Primary Filter (Bitmask)**: Use a 256-bit vector where each bit corresponds to a distinct Type ID.
* Operation: `(SigMask & BundleMask) == BundleMask` provides a fast rejection filter.


2. **Secondary Validation (Integer Product)**: If the bitmask matches, compute the full Integer Product to verify multiplicity.
* This avoids BigInt arithmetic for the 99% of non-matching cases.



---

### 8. Detailed Comparison

**Table 2: Encoding Strategy Comparison**

| Feature | Gödel Numbering | Bitmask (Set) | Prime Product (Multiset) | Gabion Proposed |
| --- | --- | --- | --- | --- |
| **Base Elements** | Primes as Positions<br>

<br> | Primes as Indices<br>

<br> | Primes as Values<br>

<br> | Primes as Values |
| **Order Sensitive** | Yes | No | No | **No** |
| **Multiplicity** | Yes | No (Idempotent) | Yes | **Yes** |
| **Collision Risk** | None | High (if hashed) | None | **None** |
| **Complexity** | Extremely High Integers | Constant Time | BigInt Arithmetic | **Hybrid** |

---

# Appendix: Formal Specification (Agda & Python)

To fulfill the requirement for **Agda** and **Python** representations of the formulae, the following definitions formalize the "Algebra of Types."

### A. Agda Specification (The Ring of Types)

This snippet defines the isomorphism between the `Bundle` type and `Nat` (Natural Numbers), proving that the operations on Types form a Commutative Monoid (and part of a Ring structure).

```agda
module Gabion.Algebra where

open import Data.Nat using (ℕ; _*_; _+_; _^_; gcd; lcm)
open import Data.List using (List; map; foldr)
open import Data.Product using (_×_)

-- 1. The Primitive Domain
-- We assume a mapping exists from a Type 'T' to a Prime 'P'
postulate
  Type : Set
  toPrime : Type → ℕ  -- The mapping function p(t)

-- 2. The Composite Domain (Bundles)
Bundle : Set
Bundle = List Type

-- 3. The Fundamental Isomorphism
-- Fingerprint F(B) = product of mapped primes
fingerprint : Bundle → ℕ
fingerprint []       = 1
fingerprint (t ∷ ts) = (toPrime t) * (fingerprint ts)

-- 4. Structural Arithmetic Operations
-- These define the algebra on the Integer representation

-- Intersection (Common Substructure)
_∩_ : ℕ → ℕ → ℕ
a ∩ b = gcd a b

-- Union (Composite Expression / Merge)
_∪_ : ℕ → ℕ → ℕ
a ∪ b = lcm a b

-- Subtyping (Containment Check)
-- Returns true if 'sub' is a factor of 'super'
is-subtype : (sub super : ℕ) → Set
is-subtype sub super = ∃ (λ k → super ≡ sub * k)

-- Symmetric Difference (XOR)
-- Corresponds to (A ∪ B) / (A ∩ B)
_⊕_ : ℕ → ℕ → ℕ
a ⊕ b = (lcm a b) / (gcd a b) -- Note: Agda div requires proof of divisibility

```

### B. Python Specification (The Arithmetic Engine)

This snippet implements the hybrid operations described in Section 4.3 and 7.

```python
import math
from functools import reduce
from typing import List, Tuple

# Type Alias for our "Compressed" forms
Fingerprint = int
BitMask = int

def structural_xor(a: Fingerprint, b: Fingerprint) -> Fingerprint:
    """
    Computes the Structural Symmetric Difference.
    Formula: LCM(a, b) // GCD(a, b)
    Result: The product of factors present in one but not the other.
    """
    intersection = math.gcd(a, b)
    union = (a * b) // intersection  # LCM = (a*b)/gcd
    
    # The 'difference' is the Union with the Intersection removed
    return union // intersection

def is_subtype(sub: Fingerprint, super: Fingerprint) -> bool:
    """
    Checks if 'sub' is contained within 'super'.
    Formula: super % sub == 0
    """
    return super % sub == 0

def merge_bundles(bundles: List[Fingerprint]) -> Fingerprint:
    """
    Computes the Union of multiple bundles (LCM).
    """
    return reduce(lambda a, b: math.lcm(a, b), bundles, 1)

# Example Verification
# int -> 2, str -> 3
# Bundle A: {int, str} -> 6
# Bundle B: {int, int} -> 4
# XOR: {str} (3) * {int} (2) = 6? 
# Wait: LCM(6,4)=12. GCD(6,4)=2. XOR = 12//2 = 6.
# Factors of 6 are 2,3.
# A has {2, 3}. B has {2, 2}.
# Non-shared: 3 (from A) and one 2 (from B). Product 6. Correct.

```