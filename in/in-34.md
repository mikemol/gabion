---
doc_revision: 2
reader_reintern: Reader-only: re-intern if doc_revision changed since you last read this doc.
doc_id: in_34
doc_role: in_step
doc_scope:
  - repo
  - analysis
  - semantics
  - tooling
doc_authority: normative
doc_owner: maintainer
doc_requires:
  - POLICY_SEED.md#policy_seed
  - glossary.md#contract
  - glossary.md#aspf
  - glossary.md#forest
  - glossary.md#suite_site
  - CONTRIBUTING.md#contributing_contract
  - README.md#repo_contract
  - AGENTS.md#agent_obligations
  - in/in-30.md#in_in_30
doc_reviewed_as_of:
  POLICY_SEED.md#policy_seed: 1
  glossary.md#contract: 1
  glossary.md#aspf: 1
  glossary.md#forest: 1
  glossary.md#suite_site: 1
  CONTRIBUTING.md#contributing_contract: 1
  README.md#repo_contract: 1
  AGENTS.md#agent_obligations: 1
  in/in-30.md#in_in_30: 4
doc_review_notes:
  POLICY_SEED.md#policy_seed: Reviewed policy seed; no conflict with analysis-surface extension.
  glossary.md#contract: Reviewed semantic contract; preserves commuting obligations.
  glossary.md#aspf: Reviewed ASPF terms for carrier extension.
  glossary.md#forest: Reviewed forest materialization constraints.
  glossary.md#suite_site: Reviewed suite locality requirements.
  CONTRIBUTING.md#contributing_contract: Workflow obligations unchanged.
  README.md#repo_contract: LSP-first invariant unaffected.
  AGENTS.md#agent_obligations: Agent obligations unchanged.
  in/in-30.md#in_in_30: Reuses Face/Kit/Solver template and carrier terminology.
doc_change_protocol: POLICY_SEED.md#change_protocol
doc_sections:
  in_in_34: 1
doc_section_requires:
  in_in_34:
    - POLICY_SEED.md#policy_seed
    - glossary.md#contract
    - glossary.md#aspf
    - glossary.md#forest
    - glossary.md#suite_site
    - in/in-30.md#in_in_30
doc_section_reviews:
  in_in_34:
    POLICY_SEED.md#policy_seed:
      dep_version: 1
      self_version_at_review: 1
      outcome: no_change
      note: "Execution-policy constraints preserved."
    glossary.md#contract:
      dep_version: 1
      self_version_at_review: 1
      outcome: no_change
      note: "Semantic typing obligations preserved."
    glossary.md#aspf:
      dep_version: 1
      self_version_at_review: 1
      outcome: no_change
      note: "Carrier extension aligns with ASPF model."
    glossary.md#forest:
      dep_version: 1
      self_version_at_review: 1
      outcome: no_change
      note: "Forest additivity preserved."
    glossary.md#suite_site:
      dep_version: 1
      self_version_at_review: 1
      outcome: no_change
      note: "SuiteSite locality preserved."
    in/in-30.md#in_in_30:
      dep_version: 4
      self_version_at_review: 1
      outcome: no_change
      note: "Template constraints adopted."
---

<a id="in_in_34"></a>

# in/in-34.md
## Index lambda/closure callables as first-class function sites

### Purpose
Promote lambda/closure callables to first-class executable sites so call-resolution, call-candidate materialization, and bundle propagation can include them as stable nodes in the same carrier as named functions.

### Non-goals
- No runtime execution / tracing.
- No whole-program points-to analysis.
- No attempt to fully model metaprogramming or eval/exec.

### Status
implemented â€” lambda/closure callable indexing and resolution are landed with conservative unresolved fallback for dynamic dispatch.

Normative pointers: [POLICY_SEED.md#policy_seed](POLICY_SEED.md#policy_seed), [glossary.md#contract](glossary.md#contract), [glossary.md#aspf](glossary.md#aspf), [glossary.md#forest](glossary.md#forest), [glossary.md#suite_site](glossary.md#suite_site), [in/in-30.md#in_in_30](in/in-30.md#in_in_30), [docs/sppf_checklist.md#in-34-lambda-callable-sites](docs/sppf_checklist.md#in-34-lambda-callable-sites).

### Implemented evidence
- Key functions (`src/gabion/analysis/dataflow_audit.py`): `_synthetic_lambda_name`, `_collect_lambda_function_infos`, `_collect_lambda_bindings_by_caller`, `_collect_closure_lambda_factories`, `_resolve_callee`, `_resolve_callee_outcome`, `_callsite_evidence_for_bundle`.
- Callsite capture (`src/gabion/analysis/visitors.py`): `UseVisitor.visit_Call` now emits callable kind/source context for lambda, closure, and function call shapes.
- Acceptance tests (`tests/`):
  - inline lambda assigned then called: `tests/test_dataflow_resolve_callee.py::test_resolve_callee_bound_lambda_call`
  - closure returned and invoked: `tests/test_dataflow_resolve_callee.py::test_resolve_callee_closure_returned_and_invoked`
  - bound lambda via object attribute: `tests/test_dataflow_resolve_callee.py::test_resolve_callee_bound_lambda_via_object_attribute`
  - unresolved/dynamic fallback path: `tests/test_dataflow_resolve_callee.py::test_resolve_callee_outcome_keeps_dynamic_fallback_for_attribute_calls`
  - callable-context evidence payload: `tests/test_callsite_evidence_helper.py::test_callsite_evidence_includes_callable_context`

---

## Face / Kit / Solver

### Face (obligations)
- **F1:** Lambda callables acquire stable, deterministic synthetic identities.
- **F2:** Synthetic identities are materialized as `FunctionSite`/`SuiteSite` and participate in `CallCandidate`.
- **F3:** Existing named-function behavior remains unchanged.
- **F4:** Unresolvable lambda dispatch remains explicit (no silent false positives).

### Kit (existing machinery)
- `src/gabion/analysis/dataflow_audit.py`
  - `_collect_functions`
  - `_accumulate_function_index_for_tree`
  - `_resolve_callee`, `_resolve_callee_outcome`
  - `_materialize_call_candidates`
- `src/gabion/analysis/visitors.py`
  - `UseVisitor` call capture (`CallArgs`)
- Forest carrier:
  - `FunctionSite`, `SuiteSite`, `CallCandidate`

### Solver (implementation plan)
1. **Introduce lambda site identity**
   - Add helper to generate deterministic synthetic callable IDs from enclosing qual + span (line/col tuple).
   - Preserve stability under deterministic parse/order conditions.

2. **Index lambdas into callable inventory**
   - Extend function collection/index assembly so `ast.Lambda` contributes `FunctionInfo`-compatible entries (or equivalent internal carrier record).
   - Ensure lexical scope and class scope are recorded where applicable.

3. **Bridge variable-bound lambda calls**
   - Track simple assignments `x = lambda ...` and resolve `x(...)` to synthetic lambda qual within scope.
   - Reuse existing scope disambiguation strategy where possible.

4. **Integrate call resolution**
   - Update `_resolve_callee` / `_resolve_callee_outcome` to consider synthetic lambda candidates.
   - Keep ambiguity handling consistent with named functions.

5. **Forest materialization**
   - Ensure lambda-resolved calls emit `CallCandidate` edges and associated suite sites.

6. **Conservative fallback**
   - If lambda target cannot be deterministically identified, emit unresolved state (do not guess).

---

## Acceptance criteria

1. Direct lambda invocation in expression position can be represented as a callable site in analysis output.
2. Bound lambda (`f = lambda ...; f(...)`) resolves in-scope and participates in call candidates.
3. Closure-lambda forwarding can contribute to dataflow bundle propagation where argument mapping is explicit.
4. No regressions in existing named-function and method-resolution test cases.
5. Ambiguous/non-resolvable lambda dispatch remains explicit as unresolved/ambiguous outcomes.

---

## Test plan (static + unit)

- Add focused tests near:
  - `tests/test_dataflow_resolve_callee.py`
  - `tests/test_dataflow_audit_coverage_gaps.py`
- Cases:
  - `(lambda x: x)(a)`
  - `f = lambda x, y: g(x, y); f(a, b)`
  - nested lambda in function scope
  - ambiguous variable shadowing among lambda/name callables

---

## Risks and mitigations

- **Risk:** synthetic-ID instability across parse changes.
  - **Mitigation:** include precise span + enclosing scope in ID; document stability assumptions.
- **Risk:** false-positive resolution from aggressive aliasing.
  - **Mitigation:** restrict to direct local assignment forms first; conservative unresolved fallback.
