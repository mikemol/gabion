---
doc_revision: 1
reader_reintern: Reader-only: re-intern if doc_revision changed since you last read this doc.
doc_id: in_36
doc_role: in_step
doc_scope:
  - repo
  - analysis
  - semantics
  - tooling
doc_authority: normative
doc_owner: maintainer
doc_requires:
  - POLICY_SEED.md#policy_seed
  - glossary.md#contract
  - glossary.md#aspf
  - glossary.md#forest
  - CONTRIBUTING.md#contributing_contract
  - README.md#repo_contract
  - AGENTS.md#agent_obligations
  - in/in-30.md#in_in_30
doc_reviewed_as_of:
  POLICY_SEED.md#policy_seed: 1
  glossary.md#contract: 1
  glossary.md#aspf: 1
  glossary.md#forest: 1
  CONTRIBUTING.md#contributing_contract: 1
  README.md#repo_contract: 1
  AGENTS.md#agent_obligations: 1
  in/in-30.md#in_in_30: 4
doc_review_notes:
  POLICY_SEED.md#policy_seed: Reviewed policy constraints; no conflict.
  glossary.md#contract: Reviewed dataflow-bundle obligations.
  glossary.md#aspf: Reviewed carrier edge materialization.
  glossary.md#forest: Reviewed evidence/reification requirements.
  CONTRIBUTING.md#contributing_contract: Workflow constraints unchanged.
  README.md#repo_contract: Scope unchanged.
  AGENTS.md#agent_obligations: Agent obligations unchanged.
  in/in-30.md#in_in_30: Template reused.
doc_change_protocol: POLICY_SEED.md#change_protocol
doc_sections:
  in_in_36: 1
doc_section_requires:
  in_in_36:
    - POLICY_SEED.md#policy_seed
    - glossary.md#contract
    - in/in-30.md#in_in_30
doc_section_reviews:
  in_in_36:
    POLICY_SEED.md#policy_seed:
      dep_version: 1
      self_version_at_review: 1
      outcome: no_change
      note: "Execution-policy constraints preserved."
    glossary.md#contract:
      dep_version: 1
      self_version_at_review: 1
      outcome: no_change
      note: "Bundle semantics preserved."
    in/in-30.md#in_in_30:
      dep_version: 4
      self_version_at_review: 1
      outcome: no_change
      note: "Template constraints adopted."
---

<a id="in_in_36"></a>

# in/in-36.md
## Handle starred dataclass constructor arguments conservatively

### Purpose
Improve dataclass-call bundle detection for simple starred constructor calls (`*...`, `**...`) without sacrificing conservative correctness.

### Non-goals
- No attempt to resolve arbitrary runtime iterables/mappings.
- No execution-time evaluation of constructor arguments.
- No broad inference beyond statically enumerable literals.

### Status
done — conservative starred dataclass constructor handling is implemented.

Normative pointers: [POLICY_SEED.md#policy_seed](POLICY_SEED.md#policy_seed), [glossary.md#contract](glossary.md#contract), [in/in-30.md#in_in_30](in/in-30.md#in_in_30), [docs/sppf_checklist.md#in-36-starred-dataclass-call-bundles](docs/sppf_checklist.md#in-36-starred-dataclass-call-bundles).

### Implemented evidence
- Key functions (`src/gabion/analysis/dataflow_audit.py`): `_iter_dataclass_call_bundles`, `_unresolved_starred_witness` (local helper within `_iter_dataclass_call_bundles`).
- Representative tests (`tests/`): `tests/test_dataflow_audit_edges.py::test_iter_dataclass_call_bundles_dynamic_starred_records_unresolved`, `tests/test_dataflow_audit_edges.py::test_iter_dataclass_call_bundles`.

---

## Face / Kit / Solver

### Face (obligations)
- **F1:** Existing strict behavior remains baseline for unknown starred forms.
- **F2:** Literal/starred argument forms may be accepted when arity/key identity is deterministic.
- **F3:** Unsupported starred forms produce explicit unresolved evidence.
- **F4:** No false-positive dataclass bundles from dynamic starred payloads.

### Kit (existing machinery)
- `src/gabion/analysis/dataflow_audit.py`
  - `_iter_dataclass_call_bundles`
  - `_collect_dataclass_registry`
  - symbol-table assisted dataclass resolution
- Forest alts:
  - `DataclassBundle`
  - `DataclassCallBundle`

### Solver (implementation plan)
1. **Factor constructor-arg decoding**
   - Extract argument decoding into helper with tri-state outcome:
     - resolved names,
     - unresolved-starred,
     - invalid-call-shape.

2. **Support conservative starred literals**
   - Accept `*` where payload is tuple/list literal and arity matches available fields.
   - Accept `**` where payload is dict literal with string keys.

3. **Merge positional/keyword/starred mapping**
   - Apply deterministic left-to-right field assignment semantics for positional+starred.
   - Reject conflicting/duplicate keyword assignments.

4. **Emit unresolved evidence**
   - When starred forms are present but undecidable, emit explicit marker/evidence row for diagnostics.
   - Preserve current “no bundle emitted” for undecidable cases (plus evidence).

5. **Retain strict fallback**
   - Any non-literal or shape-ambiguous starred payload remains unresolved and non-promoting.

---

## Acceptance criteria

1. Existing non-starred dataclass bundle detection remains unchanged.
2. `Type(*[1,2])` and `Type(**{"x":1,"y":2})` style literals can be recognized conservatively.
3. Mixed deterministic forms (positional + literal `**`) produce expected field bundle.
4. Dynamic starred payloads do not produce false positives and are explicitly surfaced as unresolved.
5. Cross-file/imported dataclass resolution behavior remains intact.

---

## Test plan

- Extend:
  - `tests/test_dataclass_call_bundles.py`
  - `tests/test_dataflow_dataclass_bundles.py`
- Add cases:
  - literal tuple/list starred positional
  - literal dict starred keyword
  - duplicate keyword collision
  - non-literal mapping/iterable fallback to unresolved evidence

---

## Risks and mitigations

- **Risk:** subtle mismatch with Python call binding semantics.
  - **Mitigation:** align helper with a narrow, documented subset; reject anything outside subset.
- **Risk:** noisy unresolved evidence.
  - **Mitigation:** cap/report summarization and stable lint wording.
