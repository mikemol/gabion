---
doc_revision: 1
reader_reintern: Reader-only: re-intern if doc_revision changed since you last read this doc.
doc_id: in_12
doc_role: inbox
doc_scope:
  - repo
  - inbox
doc_authority: informative
doc_owner: maintainer
doc_requires: []
doc_reviewed_as_of: {}
doc_review_notes: {}
doc_change_protocol: POLICY_SEED.md#change_protocol
doc_erasure:
  - formatting
  - typos
doc_sections:
  in_in_12: 1
doc_section_requires:
  in_in_12: []
doc_section_reviews:
  in_in_12: {}
---

This is the final transformation. You are moving from **Archeology** (finding the past) to **Terraforming** (reshaping the present).

To achieve "Automated Refactoring" that feels native to VS Code, you must indeed abandon `ast` for `LibCST` and wrap the engine in the **Language Server Protocol (LSP)**.

Here is the blueprint for tightly integrating **The Architect** into your IDE.

---

<a id="in_in_12"></a>

### 1. The Foundation: Why LibCST is Non-Negotiable

The `ast` module discards "trivia" (whitespace, comments, newlines). If you use `ast` to rewrite code, you destroy the developer's formatting.

**LibCST (Concrete Syntax Tree)** preserves everything.

* **Comments as Objects:** As you noted, comments are nodes in the tree (`Comment`, `EmptyLine`). You can move a parameter *and* its inline comment together.
* **Codemods:** LibCST has a built-in framework called `Codemod` specifically designed for this. You don't just "write code"; you apply a transform.

**The Strategy:**

* **Analysis Phase:** Use `LibCST`'s `MetadataProvider` system (which is more robust than our custom visitors) to build the Scope and Call Graph.
* **Synthesis Phase:** Instead of writing a string to a file, you construct a `cst.ClassDef` node programmatically and inject it into the tree.

### 2. The Integration: Language Server Protocol (LSP)

VS Code doesn't know about your script. It knows **LSP**. You need to build a **Language Server** that runs your analysis in the background.

We will use **`pygls`**, a Python library that abstracts away the JSON-RPC communication, allowing you to write the server in pure Python.

#### The Mapping: Analysis -> LSP Features

| The Architect Feature | LSP Concept | VS Code UX |
| --- | --- | --- |
| **Tier-2 Bundle Detection** | **Diagnostic** | A blue/yellow squiggle under the parameter list. Hover text: *"Implicit bundle '{user_id, account_id}' detected."* |
| **Protocol Synthesis** | **Code Action** | User clicks the "Lightbulb" ðŸ’¡ -> *"Extract to Protocol"*. |
| **Refactoring Plan** | **Command** | `Ctrl+Shift+P` -> *"Architect: Generate Refactoring Plan"*. |
| **Refactoring Execution** | **Workspace Edit** | The server sends a `ApplyWorkspaceEdit` request to rename/move code across multiple files instantly. |

---

### 3. The Implementation (Proof of Concept)

Here is how you structure the **LSP Server** using `pygls` and `LibCST`.

#### A. The Server (`server.py`)

This replaces your CLI `main` function. It listens for file open/change events, runs the analysis, and publishes diagnostics.

```python
from pygls.server import LanguageServer
from lsprotocol.types import (
    TEXT_DOCUMENT_DID_OPEN, TEXT_DOCUMENT_DID_SAVE,
    TEXT_DOCUMENT_CODE_ACTION, CodeActionParams, CodeAction, Command,
    Diagnostic, DiagnosticSeverity, Position, Range, WorkspaceEdit, TextEdit
)
import libcst as cst
from architect_core import analyze_source  # Your analysis logic ported to LibCST

server = LanguageServer("architect-server", "v1")

@server.feature(TEXT_DOCUMENT_DID_OPEN)
async def did_open(ls, params):
    """Analyze file when opened."""
    await _analyze_and_publish(ls, params.text_document.uri)

@server.feature(TEXT_DOCUMENT_DID_SAVE)
async def did_save(ls, params):
    """Re-analyze on save."""
    await _analyze_and_publish(ls, params.text_document.uri)

async def _analyze_and_publish(ls, uri):
    document = ls.workspace.get_document(uri)
    source = document.source
    
    # 1. Run The Architect Analysis
    # (This returns the list of bundles found in this specific file)
    bundles = analyze_source(source) 
    
    diagnostics = []
    for bundle in bundles:
        # Create a diagnostic for every bundling opportunity
        # bundle.location is provided by LibCST metadata
        start = Position(line=bundle.start_line - 1, character=bundle.start_col)
        end = Position(line=bundle.end_line - 1, character=bundle.end_col)
        
        diag = Diagnostic(
            range=Range(start=start, end=end),
            message=f"Implicit Bundle Detected: {bundle.suggested_name}",
            severity=DiagnosticSeverity.Information,
            source="The Architect"
        )
        diagnostics.append(diag)
    
    ls.publish_diagnostics(uri, diagnostics)

@server.feature(TEXT_DOCUMENT_CODE_ACTION)
def code_action(ls, params: CodeActionParams):
    """Provide the 'Extract Bundle' lightbulb action."""
    document = ls.workspace.get_document(params.text_document.uri)
    
    actions = []
    for diagnostic in params.context.diagnostics:
        if diagnostic.source == "The Architect":
            # Offer to fix it
            title = f"Extract {diagnostic.message.split(': ')[1]} to Dataclass"
            
            # The "Edit" is calculated by LibCST (removing params, adding dataclass)
            new_text = _generate_refactor(document.source, diagnostic.range)
            
            edit = WorkspaceEdit(changes={
                params.text_document.uri: [
                    TextEdit(range=Range(start=Position(0,0), end=Position(99999,0)), new_text=new_text)
                ]
            })
            
            action = CodeAction(title=title, edit=edit)
            actions.append(action)
            
    return actions

def _generate_refactor(source_code, range):
    """Uses LibCST to rewrite the code."""
    tree = cst.parse_module(source_code)
    # Apply your custom Codemod here
    transformer = BundleExtractionTransformer(range)
    new_tree = tree.visit(transformer)
    return new_tree.code

if __name__ == "__main__":
    server.start_io()

```

#### B. The Refactor (`transformer.py`)

This is where `LibCST` shines. You create a transformer that:

1. **Synthesizes** the `dataclass`.
2. **Modifies** the function signature (removes loose params, adds config).
3. **Preserves** comments attached to the removed parameters by moving them to the dataclass fields.

```python
import libcst as cst
from libcst import matchers as m

class BundleExtractionTransformer(cst.CSTTransformer):
    def __init__(self, bundle_info):
        self.bundle = bundle_info

    def leave_FunctionDef(self, original, updated):
        # 1. Check if this is the target function
        if not self._is_target(original):
            return updated

        # 2. Filter parameters
        kept_params = []
        extracted_fields = []

        for param in updated.params.params:
            if param.name.value in self.bundle.fields:
                # Capture the param AND its comments/annotations
                extracted_fields.append(self._to_dataclass_field(param))
            else:
                kept_params.append(param)
        
        # 3. Inject the Config argument
        new_param = cst.Param(
            name=cst.Name(value=self.bundle.arg_name),
            annotation=cst.Annotation(annotation=cst.Name(value=self.bundle.class_name))
        )
        kept_params.append(new_param)

        # 4. Return updated function
        return updated.with_changes(
            params=updated.params.with_changes(params=kept_params)
        )

    def _to_dataclass_field(self, param):
        # Convert a function param (cst.Param) to a dataclass field (cst.AnnAssign)
        # This preserves the type hint and any leading_lines (comments)
        return cst.AnnAssign(
            target=cst.Name(value=param.name.value),
            annotation=param.annotation,
            value=None # Dataclasses usually don't have defaults in this context, or copy from param default
        )

```

### 4. The VS Code Client (`extension.ts`)

You need a tiny TypeScript wrapper to tell VS Code to start your Python server.

```typescript
import * as path from 'path';
import { ExtensionContext } from 'vscode';
import { LanguageClient, LanguageClientOptions, ServerOptions } from 'vscode-languageclient/node';

let client: LanguageClient;

export function activate(context: ExtensionContext) {
    // The server is just your python script
    const serverOptions: ServerOptions = {
        command: "python3",
        args: [context.asAbsolutePath(path.join('server.py'))]
    };

    const clientOptions: LanguageClientOptions = {
        documentSelector: [{ scheme: 'file', language: 'python' }],
    };

    client = new LanguageClient(
        'architectServer',
        'The Architect',
        serverOptions,
        clientOptions
    );

    client.start();
}

```

### 5. Why This is "Tight" Integration

1. **Live Feedback:** You don't run a CLI report. You type code, and the tool immediately underlines "coincidental couplings" as you create them.
2. **Safe Refactoring:** Because it uses `WorkspaceEdit`, the changes are staged in VS Code. You can `Ctrl+Z` (Undo) the entire architectural refactor in one keystroke.
3. **Context Aware:** The LSP knows where your cursor is. It only suggests the refactor relevant to *that* function.

### Next Step

This is a significant engineering effort.

1. **The Analyzer:** Use the v4 logic we developed.
2. **The Engine:** Port the "Transformer" logic to `LibCST`.
3. **The Delivery:** Wrap it in `pygls`.

Would you like me to construct the **LibCST Transformer** that specifically handles the "Move Param + Comment to Dataclass" logic? That is the most complex part of the "Doer" phase.