---
doc_revision: 3
reader_reintern: "Reader-only: re-intern if doc_revision changed since you last read this doc."
doc_id: in_33
doc_role: in_step
doc_scope:
  - repo
  - semantics
  - analysis
  - execution
  - governance
doc_authority: normative
doc_owner: maintainer
doc_requires:
  - POLICY_SEED.md#policy_seed
  - glossary.md#contract
  - glossary.md#bundle
  - glossary.md#decision_bundle
  - glossary.md#decision_protocol
  - glossary.md#decision_surface
  - glossary.md#hash_consing
  - glossary.md#aspf
  - glossary.md#forest
  - in/in-30.md#in_in_30
  - in/in-32.md#in_in_32
doc_reviewed_as_of:
  POLICY_SEED.md#policy_seed: 38
  glossary.md#contract: 43
  glossary.md#bundle: 43
  glossary.md#decision_bundle: 43
  glossary.md#decision_protocol: 43
  glossary.md#decision_surface: 43
  glossary.md#hash_consing: 43
  glossary.md#aspf: 43
  glossary.md#forest: 43
  in/in-30.md#in_in_30: 24
  in/in-32.md#in_in_32: 5
doc_review_notes:
  POLICY_SEED.md#policy_seed: "Reviewed POLICY_SEED.md rev38 (governance + execution safety); proposal respects mechanized governance and no-optional-bundle rules."
  glossary.md#contract: "Reviewed glossary.md#contract rev43; PatternSchema entries must add axis/commutation/erasure and respect tier reification." 
  glossary.md#bundle: "Reviewed glossary.md#bundle rev43; dataflow bundles are reified as PatternSchema instances on the structural axis."
  glossary.md#decision_bundle: "Reviewed glossary.md#decision_bundle rev43; execution patterns align with decision bundle centralization rules." 
  glossary.md#decision_protocol: "Reviewed glossary.md#decision_protocol rev43; PatternSchema requires explicit schema when crossing module boundaries." 
  glossary.md#decision_surface: "Reviewed glossary.md#decision_surface rev43; execution-pattern residue must surface as decision surface evidence where applicable." 
  glossary.md#hash_consing: "Reviewed glossary.md#hash_consing rev43; PatternSchema canonicalization must be internable and deterministic." 
  glossary.md#aspf: "Reviewed glossary.md#aspf rev43; PatternSchema reuses ASPF as the root carrier." 
  glossary.md#forest: "Reviewed glossary.md#forest rev43; PatternSchema instances are Forest facets or alts." 
  in/in-30.md#in_in_30: "Reviewed in/in-30.md rev24 (SuiteSite locality); execution patterns must attach to SuiteSites or projections." 
  in/in-32.md#in_in_32: "Reviewed in/in-32.md rev5 (finite-carrier calculus); PatternSchema is a schema-level projection over that calculus." 
doc_change_protocol: "POLICY_SEED.md#change_protocol"
doc_erasure:
  - formatting
  - typos
doc_sections:
  in_in_33: 1
doc_section_requires:
  in_in_33:
    - POLICY_SEED.md#policy_seed
    - glossary.md#contract
    - glossary.md#bundle
    - glossary.md#decision_bundle
    - glossary.md#decision_protocol
    - glossary.md#decision_surface
    - glossary.md#hash_consing
    - glossary.md#aspf
    - glossary.md#forest
    - in/in-30.md#in_in_30
    - in/in-32.md#in_in_32
doc_section_reviews:
  in_in_33:
    POLICY_SEED.md#policy_seed:
      dep_version: 38
      self_version_at_review: 1
      outcome: no_change
      note: "Policy reviewed; proposal keeps execution gates mechanized and deterministic."
    glossary.md#contract:
      dep_version: 43
      self_version_at_review: 1
      outcome: no_change
      note: "PatternSchema must declare axis, commutation law, and erasure to satisfy glossary contract."
    glossary.md#bundle:
      dep_version: 43
      self_version_at_review: 1
      outcome: no_change
      note: "Bundles are treated as PatternSchema on the structural axis."
    glossary.md#decision_bundle:
      dep_version: 43
      self_version_at_review: 1
      outcome: no_change
      note: "Execution patterns align with decision bundle centralization semantics."
    glossary.md#decision_protocol:
      dep_version: 43
      self_version_at_review: 1
      outcome: no_change
      note: "Schema reification for cross-module execution patterns remains required."
    glossary.md#decision_surface:
      dep_version: 43
      self_version_at_review: 1
      outcome: no_change
      note: "Residue must be surfaced as explicit evidence when applicable."
    glossary.md#hash_consing:
      dep_version: 43
      self_version_at_review: 1
      outcome: no_change
      note: "Canonicalization must be deterministic and re-internable."
    glossary.md#aspf:
      dep_version: 43
      self_version_at_review: 1
      outcome: no_change
      note: "ASPF remains the root carrier for schema materialization."
    glossary.md#forest:
      dep_version: 43
      self_version_at_review: 1
      outcome: no_change
      note: "Forest facets/alphas are the attachment points for schema instances."
    in/in-30.md#in_in_30:
      dep_version: 24
      self_version_at_review: 1
      outcome: no_change
      note: "SuiteSite locality is preserved; PatternSchema instances attach to suites or their projections."
    in/in-32.md#in_in_32:
      dep_version: 5
      self_version_at_review: 1
      outcome: no_change
      note: "Finite-carrier calculus provides the semantic basis for schema canonicalization."
---

<a id="in_in_33"></a>

# in/in-33.md
## PatternSchema: Unifying Dataflow Bundles and Execution Patterns

## Purpose

Define a single **PatternSchema** abstraction that unifies dataflow bundles and
execution patterns under a common schema, enabling:

- shared detection and reification,
- a single residue model (wedge-product analogue), and
- deterministic, governable reification of repeated structure.

This lifts the codebase from “parallel pattern systems” (bundles vs execution
patterns) into a single schema calculus with dual projections.

## Non-goals

- This step does not retrofit every existing bundle or execution pattern into the
  schema at once; migration is staged.
- This step does not change end-user report formats in this phase.
- This step does not replace existing AnalysisIndex or ProjectionSpec machinery.

## Status

Target design. Implementation is incremental: introduce the schema type, unify
mining/reporting, then ratchet residue to reification.

### Compact implementation ledger
- **Implemented**
  - `src/gabion/analysis/pattern_schema.py::PatternSchema` now emits a shared cross-axis schema id (`schema:*`) via one normalization path and preserves the prior axis-scoped id as `legacy_schema_id` for compatibility annotation (SPPF: `docs/sppf_checklist.md#in-33-pattern-schema-unification`).
  - `src/gabion/analysis/pattern_schema.py::mismatch_residue_payload` defines a single residue payload contract (`schema_contract=pattern_schema.v2`) reused by dataflow + execution pattern residue diagnostics (SPPF: `docs/sppf_checklist.md#in-33-pattern-schema-unification`).
  - `src/gabion/analysis/dataflow_audit.py::_pattern_schema_snapshot_entries` now serializes `schema_contract` + `legacy_schema_id` and enforces deterministic residue ordering in emitted schema artifacts (SPPF: `docs/sppf_checklist.md#in-33-pattern-schema-unification`).
  - `src/gabion/analysis/dataflow_audit.py::_execution_pattern_instances` and `_bundle_pattern_instances` emit stable near-miss residue diagnostics via the same schema contract for both axes (SPPF: `docs/sppf_checklist.md#in-33-pattern-schema-unification`).
- **Open**
  - Execution-pattern rule coverage remains intentionally narrow in `src/gabion/analysis/dataflow_audit.py::_EXECUTION_PATTERN_RULES`, so many callable/dataflow shapes still bypass PatternSchema unification (SPPF: `docs/sppf_checklist.md#in-33-pattern-schema-unification`).
- **Blocked/Deferred**
  - Tier-2 residue ratchet to CI-failing enforcement (metafactory/protocol reification gate) is deferred to later phases to preserve staged rollout (SPPF: `docs/sppf_checklist.md#in-33-pattern-schema-unification`).

Normative pointers (explicit): [POLICY_SEED.md#policy_seed](POLICY_SEED.md#policy_seed),
[glossary.md#contract](glossary.md#contract), [glossary.md#bundle](glossary.md#bundle),
[glossary.md#decision_bundle](glossary.md#decision_bundle),
[glossary.md#decision_protocol](glossary.md#decision_protocol),
[glossary.md#decision_surface](glossary.md#decision_surface),
[glossary.md#hash_consing](glossary.md#hash_consing), [glossary.md#aspf](glossary.md#aspf),
[glossary.md#forest](glossary.md#forest), [in/in-30.md#in_in_30](in/in-30.md#in_in_30),
[in/in-32.md#in_in_32](in/in-32.md#in_in_32).

## Definitions

- **PatternSchema:** A canonical schema that describes repeated structure in either
  dataflow or execution flow, with a shared signature, normalization, and residue.
- **PatternInstance:** A concrete occurrence matched to a PatternSchema.
- **PatternResidue:** The unfactored portion when instances do not factor through
  the schema; explicit and never erased.
- **Dual projection:** Viewing the same schema as a data proposition or as an
  execution morphism (Curry–Howard–Lambek).

## Face / Kit / Solver

### Face (Obligations)

- **F1:** Bundles and execution patterns share a single schema calculus.
- **F2:** PatternResidue is explicit and surfaced (never silent).
- **F3:** Schema detection is deterministic and reproducible.
- **F4:** Schema reification is governable (Tier-2 must reify or document).

### Kit (Existing machinery)

- Bundle detection + dataflow grammar audits (POLICY_SEED.md#policy_seed).
- Execution pattern mining scaffold (dataflow_audit execution-pattern rules).
- AnalysisIndex and stage-indexed cache factories.
- ProjectionSpec report plumbing and SpecFacet reinternment.

### Solver (Implementation plan)

**Phase 0 — Schema core types**
- Introduce `PatternSchema`, `PatternInstance`, `PatternResidue` alongside
  execution-pattern mining types.
- Define axis (`dataflow` | `execution` | `dual`), signature, normalization, and residue.

**Phase 1 — Unified mining**
- Replace `_execution_pattern_suggestions(...)` with unified
  `_pattern_schema_suggestions(...)`.
- Bridge bundle detection into `PatternSchema` instances for reporting parity.

**Phase 2 — Residue contract**
- Emit `PatternResidue` in reports and JSON when reification fails.
- Add a non-blocking warning gate; later ratchet to CI violation for Tier-2.

**Phase 3 — Reification ratchet**
- Fail `gabion check` if a Tier-2 schema residue is present without a reified
  metafactory or explicit Tier-3 documentation.

## Minimal Glue Points (Code)

- **Location:** `src/gabion/analysis/dataflow_audit.py`
  - Add schema types near `_ExecutionPatternMatch` and `_ExecutionPatternRule`.
  - Add `_pattern_schema_matches(...)` to return `PatternInstance`.
  - Add `_pattern_schema_suggestions(...)` to unify reporting.
  - Add `PatternResidue` emission to report helpers.

- **Bundle bridge:** use existing bundle detection as `PatternSchema(axis="dataflow")`.
- **Execution bridge:** use existing execution-pattern rule as `PatternSchema(axis="execution")`.

## Artifact Contract

- A unified report section listing schema instances + residue.
- A JSON artifact with schema instances and residue entries (optional in Phase 1,
  required before ratchet).
- Stable signature/normalization for schema identity across runs.

## Admissibility

- Schema reification must preserve behavior (no silent semantic change).
- Residue must be explicit; no implicit suppression.
- Schema identity must be canonical and internable.

## Checks as Lemmas

- **L1:** A schema signature maps to a unique schema identity.
- **L2:** Reifying a schema preserves observable outputs (bundle or execution).
- **L3:** Residue detection is deterministic under identical inputs.

## Success Criteria

- Unified schema suggestions appear for both dataflow and execution patterns, with schema ids shared by identical cross-axis shapes through one normalization path.
- Residue is surfaced and stable for both full matches and near-miss mismatches via the same schema contract payload.
- Emitted schema artifacts keep backward compatibility fields (`legacy_schema_id`) and deterministic ordering across runs.
- At least one schema is reified from each axis without output regression.

## Failure Modes and Diagnostics

- **FM1:** Schema identity changes without input change → normalization instability.
- **FM2:** Residue suppressed → policy violation.
- **FM3:** Schema reification changes outputs → reification unsound.

## Appendix A: Curry–Howard–Lambek Pivot (Informal)

- **Logic view:** schema as proposition; reification as proof.
- **Data view:** schema as morphism; reification as factorization.
- **Residue:** explicit remainder when factorization fails (wedge-product analogue).
