---
doc_revision: 3
reader_reintern: "Reader-only: re-intern if doc_revision changed since you last read this doc."
doc_id: in_24
doc_role: in_step
doc_scope:
  - repo
  - tooling
  - research
  - semantics
doc_authority: normative
doc_requires:
  - POLICY_SEED.md
  - glossary.md
  - CONTRIBUTING.md
  - README.md
  - AGENTS.md
  - in/in-23.md
  - out/out-3.md
doc_reviewed_as_of:
  POLICY_SEED.md: 32
  glossary.md: 29
  CONTRIBUTING.md: 76
  README.md: 59
  AGENTS.md: 13
  in/in-23.md: 1
  out/out-3.md: 3
doc_review_notes:
  POLICY_SEED.md: "Reviewed POLICY_SEED.md rev32 (branch/tag CAS + check-before-use constraints); no conflicts with this document's scope."
  glossary.md: "Reviewed glossary rev29 (obsolescence projection path + self-review/mirror definitions); deadness/environment semantics unchanged."
  CONTRIBUTING.md: "Reviewed CONTRIBUTING.md rev76 (docflow audit now scans in/ by default); no conflicts with this document's scope."
  README.md: "Reviewed README.md rev59 (docflow audit now scans in/ by default); no conflicts with this document's scope."
  AGENTS.md: "Agent obligations unchanged; evidence artifacts remain advisory."
  in/in-23.md: "Builds on ASPF carrier/provenance; consistent with carrier obligations."
  out/out-3.md: "ASPF/SPPF hypothesis provides the carrier basis for negative evidence."
doc_change_protocol: "POLICY_SEED.md §6"
doc_erasure:
  - formatting
  - typos
doc_owner: maintainer
---

# in/in-24.md

## Deadness as First-Class Evidence

### Attribute Environments, Unsat Cores, and SPPF Pruning Artifacts

---

## 0. Status

**Scope: formalization + artifactization of negative evidence.**

`in-23.md` establishes ASPF as an SPPF-equivalent **positive** semantic carrier: fingerprints, synth bases, provenance, and snapshot reproducibility. `out_3` states the hypothesis and correspondence. This step extends that contract with **negative** evidence: *proof objects that a derivation/branch does not exist under an environment*.

This step is normative: it defines new obligations and the minimal artifacts needed to satisfy them.

Normative pointers (explicit): `POLICY_SEED.md`, `glossary.md`, `CONTRIBUTING.md`, `README.md`, `AGENTS.md`, `in/in-23.md`, `out/out-3.md`.

---

## 1. Goal

Make “deadness” (dead code / unreachable derivations) a **first-class semantic artifact** that:

* is produced by the audit pipeline,
* is reproducible in snapshots,
* is exposed via CLI + LSP,
* and is structured as evidence (not merely a warning string).

Equivalently:

> If `in-23` makes packed-derivation **existence** evidence stable, `in-24` makes packed-derivation **non-existence** evidence stable.

This closes the attribute-grammar loop: derivation structure + attribute constraints together define the admissible forest.

---

## 2. Definitions (minimal, repo-native)

### 2.1 Environment (inherited attribute)

An **Environment** is the (possibly partial) constraint context propagated into a sub-derivation. It is an *inherited attribute*.

Internal synthesis point:

* constant propagation / constraint propagation already computed by analysis logic (implementation detail is irrelevant; the interface is not).

Normative minimum:

* environments must be representable as a stable, serializable set of bindings/constraints sufficient to justify deadness.

### 2.2 Deadness witness (negative evidence)

A **DeadnessWitness** is a proof object that a candidate derivation is unreachable under an environment.

It has the shape:

* `site`: `(path, function, bundle)` (same surface projection anchor as fingerprint provenance)
* `predicate`: the branch condition or decision predicate reduced
* `environment`: the environment used for reduction
* `result`: `UNREACHABLE`
* `core`: a minimal (or at least reduced) explanation trail / unsat core
* `projection`: a surface-readable summary

Internal synthesis point:

* your existing constant-prop dead-code detection is already a witness generator; this step defines the artifact boundary.

### 2.3 Deadness provenance artifact

`fingerprint_deadness.json` is the serialized list of `DeadnessWitness` entries. It is the negative-evidence sibling of `fingerprint_provenance.json`.

Normative minimum:

* stable ordering,
* stable formatting,
* explicit remainder/unknown states (no silent fallback).

---

## 3. Why deadness must be an artifact (not a log line)

`in-23`’s central move is: “semantic equivalence is witnessed and captured.”
Deadness is the dual statement:

* positive: there exists a derivation (inhabited path space)
* negative: there exists no derivation (empty path space)

If deadness remains an unstructured warning, the system cannot:

* diff deadness across commits,
* attribute changes to environment vs structure,
* or treat “branch pruning” as a stable semantic transformation.

Therefore deadness must be:

* structured,
* serializable,
* snapshot-captured,
* reloadable when relevant (environment reconstruction), and
* surfaced at the same interface boundary as provenance/matches.

---

## 4. Face / Kit / Solver (repo idiom)

### 4.1 Face (obligations)

**D1 — Evidence, not assertion**
Any claim of deadness must be accompanied by a DeadnessWitness entry.

**D2 — Environment explicitness**
Deadness must name the environment that makes the branch unreachable. If the environment is partial or unknown, that must be explicit (no implicit assumptions).

**D3 — Core reduction (anti-elision)**
A deadness witness must include a reduced explanation trail. “Reduced” does not require minimality, but it must be smaller than the full propagation trace and sufficient to justify the claim.

**D4 — Determinism and ordering**
Deadness artifacts must be deterministic across runs given the same basis + inputs.

**D5 — Snapshot reproducibility**
Audit snapshots must capture deadness artifacts so deadness diffs become meaningful.

**D6 — Interface parity**
CLI, LSP, and report must all surface the same deadness information (same entries, same IDs, same summaries), differing only in projection format.

### 4.2 Kit (available machinery)

Already present in the repo (internal synthesis point, as established by prior work and your note):

* constant propagation / dead code detection (existing analysis capability)
* surface projection anchors (path/function/bundle)
* artifact emission plumbing (JSON output, snapshot integration patterns)
* determinism enforcement habits (registry load/save; stable ordering)
* docflow audit and test-as-lemma practice

### 4.3 Solver (how obligations are discharged)

We extend the existing solver (dataflow audit pipeline) with a parallel negative-evidence path:

* detect unreachable branches during analysis (existing mechanism)
* construct `DeadnessWitness` entries with:

  * environment snapshot
  * predicate reduction
  * reduced explanation trail
* emit:

  * report section: “Deadness evidence”
  * JSON: `fingerprint_deadness.json`
* plumb through:

  * CLI and LSP response
  * snapshot capture scripts
  * latest snapshot selectors

This mirrors the `fingerprint_provenance` and `fingerprint_synth` lifecycle in `in-23`.

---

## 5. Artifact contract

### 5.1 Required artifacts (when enabled)

* `fingerprint_deadness.json`
* report section: **Deadness evidence**
* LSP field: `fingerprint_deadness` (or equivalent naming)

### 5.2 Schema obligations (normative, minimal)

Each entry must include:

* `site`:

  * `path`
  * `function`
  * `bundle`
* `environment` (serializable)
* `predicate` (pre- and post-reduction, or at least post-reduction + reference)
* `core` (reduced explanation trail)
* `result` (UNREACHABLE / UNKNOWN; UNKNOWN must not be conflated with reachable)

Ordering:

* sort by `(path, function, bundle, predicate_key)`.

---

## 6. Determinism and replay

Deadness must be reproducible across runs, which implies:

* environment capture is stable (no ephemeral IDs without stable names)
* predicate reduction is stable (canonicalization of expressions / stable pretty-print)
* core reduction is deterministic (stable ordering of constraints)

If any of these cannot yet be guaranteed, the system must:

* emit `UNKNOWN` with explicit remainder/explanation,
* never silently upgrade to `UNREACHABLE`.

---

## 7. Checks as lemmas (tests → obligations)

We introduce/require tests analogous to `in-23`:

* **Deadness entry existence** (D1):

  * for a known constant-prop scenario, ensure one `DeadnessWitness` exists

* **Environment explicitness** (D2):

  * witness includes environment bindings required for reduction

* **Core reduction** (D3):

  * witness core is non-empty and smaller than a full trace (by count/size metric)

* **Determinism** (D4):

  * same input produces byte-identical JSON (excluding timestamps if any; timestamps discouraged)

Acceptance mapping: see `docs/matrix_acceptance.md` for the minimum test suite
and schema obligations derived from the 3×3×3 matrix.

Docflow audit remains required.

---

## 8. Snapshot integration (required)

Extend snapshot scripts analogously to synth/provenance:

* `audit_snapshot.sh` writes `fingerprint_deadness.json` when enabled
* `latest_snapshot.sh`:

  * selector `--fingerprint-deadness`
  * lists the file by default when present

Deadness is not optional once the detector is active: if the system can prove unreachable, it must emit evidence.

---

## 9. Relation to SPPF and homotopy view (contract-level)

This step completes the “packed forest” picture:

* `fingerprint_provenance.json` witnesses **multiple derivations exist**
* `fingerprint_deadness.json` witnesses **certain derivations do not exist**

In SPPF terms:

* packed nodes represent alternatives
* deadness evidence prunes alternatives that are not compatible with inherited attributes

In the rewrite/higher-path view:

* deadness is evidence that a path type is empty in a given fiber (environment).

This is not speculative; it is the operational meaning of the artifact.

---

## 10. Minimal success criteria

This step is complete when:

1. `fingerprint_deadness.json` exists, is snapshot-captured, and is surfaced via CLI + LSP.
2. Each deadness claim is accompanied by:

   * explicit environment
   * reduced core/explanation
3. Determinism is enforced by tests (byte-identical artifacts across runs).
4. Deadness `UNKNOWN` is distinct from `UNREACHABLE`; no silent rounding.

---

## 11. Homology of this document (explicit self-audit)

This document extends the chain complex of `in-23`:

* **C₀**: sites + environments + predicates
* **C₁**: reductions / propagation steps (witness cores)
* **∂**: tests that map witnesses back to obligations
* **H₀**: admissible derivation components given the environment constraints
* **H₁**: explanation cycles: minimal cores that justify pruning decisions
* Higher structure: deferred (coherence of different cores/cores-of-cores)

Interpretation: the “holes” are precisely the places where deadness is asserted without sufficient environment/core evidence; this step closes those holes.

---

## 12. Orthogonal implication braid (3×3×3, concise)

### N₁ DeadnessWitness

* I₁.1 **Soundness**: UNREACHABLE implies no admissible derivation

  * I₁.1.a environment must entail predicate reduction to False
  * I₁.1.b core must justify entailment
  * I₁.1.c UNKNOWN must not be conflated with False
* I₁.2 **Explainability**: every deadness claim is reconstructible

  * I₁.2.a witness is sufficient to replay reduction
  * I₁.2.b surface projection is stable and human-meaningful
  * I₁.2.c artifacts are diffable across commits
* I₁.3 **Reproducibility**: deadness is stable under rerun

  * I₁.3.a stable ordering
  * I₁.3.b stable environment naming
  * I₁.3.c stable core extraction

### N₂ Environment

* I₂.1 **Completeness (for claim)**: only necessary bindings are required

  * I₂.1.a include bindings used by the core
  * I₂.1.b omit irrelevant bindings (core reduction)
  * I₂.1.c explicit remainder if bindings are missing
* I₂.2 **Compositionality**: environments behave as inherited attributes

  * I₂.2.a propagate into sub-derivations deterministically
  * I₂.2.b combine with local constraints predictably
  * I₂.2.c allow “fracking” to surface minimal binding set
* I₂.3 **Stability**: environment serialization is basis-independent

  * I₂.3.a avoid ephemeral IDs
  * I₂.3.b stable string forms
  * I₂.3.c versioned schema if needed

### N₃ Artifactization

* I₃.1 **Pipeline parity**: CLI/LSP/report agree

  * I₃.1.a same entries across surfaces
  * I₃.1.b stable IDs/keys
  * I₃.1.c projection differences are formatting-only
* I₃.2 **Snapshot capture**: artifacts are durable

  * I₃.2.a included in audit snapshots
  * I₃.2.b discoverable via latest_snapshot selectors
  * I₃.2.c pinned resolution when “LATEST” is used elsewhere
* I₃.3 **Audit semantics**: artifacts are obligations, not hints

  * I₃.3.a missing artifact = incomplete proof
  * I₃.3.b tests assert presence
  * I₃.3.c failure modes are explicit

---

## 13. Commands (reference)

### Local checks

* `python -m pytest -q`
* `mise exec -- python scripts/docflow_audit.py --root .`

### Audit with deadness artifact

* `gabion dataflow-audit --fingerprint-deadness-json <path> ...`

### Snapshot capture

* `./audit_snapshot.sh`
* `./latest_snapshot.sh --fingerprint-deadness`

(Flags must match repo CLI; this section is normative in intent and must be kept aligned with the implementation.)

---

## 14. Closing

`in-24` makes the negative half of the semantic picture first-class:

* **existence evidence** (provenance, synth basis) from `in-23`
* **non-existence evidence** (deadness witnesses) from this step

Together, they yield an attribute-grammar–complete packed-forest semantics:

* structure + attributes
* positive + negative evidence
* reproducible + auditable artifacts

This is the minimal foundation required before introducing:

* higher coherence move libraries,
* proof-carrying rewrites,
* and dimension genesis beyond `synth@k`.
