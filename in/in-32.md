---
doc_revision: 6
reader_reintern: "Reader-only: re-intern if doc_revision changed since you last read this doc."
doc_id: in_32
doc_role: in_step
doc_scope:
  - repo
  - architecture
  - execution-model
  - concurrency
  - verification
doc_authority: informative
doc_owner: maintainer
doc_requires:
  - POLICY_SEED.md#policy_seed
  - glossary.md#aspf
  - glossary.md#forest
  - glossary.md#hash_consing
  - CONTRIBUTING.md#contributing_contract
  - README.md#repo_contract
  - AGENTS.md#agent_obligations
  - in/in-30.md#in_in_30
doc_reviewed_as_of:
  POLICY_SEED.md#policy_seed: 1
  glossary.md#aspf: 1
  glossary.md#forest: 1
  glossary.md#hash_consing: 1
  CONTRIBUTING.md#contributing_contract: 1
  README.md#repo_contract: 1
  AGENTS.md#agent_obligations: 1
  in/in-30.md#in_in_30: 27
doc_review_notes:
  POLICY_SEED.md#policy_seed: "Reviewed POLICY_SEED.md rev1 (mechanized governance); no conflicts with this document's scope."
  glossary.md#aspf: "Reviewed glossary.md#aspf rev1 (ASPF carrier semantics); this document extends ASPF with Gödel numbering and decoration lineages."
  glossary.md#forest: "Reviewed glossary.md#forest rev1 (Forest materialized carrier); compatible with extended decoration model."
  glossary.md#hash_consing: "Reviewed glossary.md#hash_consing rev1 (hash-consing internment); Gödel numbering is a refinement, not a break."
  CONTRIBUTING.md#contributing_contract: "Reviewed CONTRIBUTING.md rev1; no conflicts."
  README.md#repo_contract: "Reviewed README.md rev1; phased migration preserves existing tooling."
  AGENTS.md#agent_obligations: "Reviewed AGENTS.md rev1; agent must enforce determinism and correctness at each phase."
  in/in-30.md#in_in_30: "Re-reviewed in/in-30.md rev27; SuiteSite and loop-suite semantics remain compatible with this document's finite-carrier migration framing."
doc_change_protocol: "POLICY_SEED.md#change_protocol"
doc_erasure:
  - spelling/formatting only
  - reflow without semantic edits
doc_sections:
  in_in_32: 6
doc_section_requires:
  in_in_32:
    - POLICY_SEED.md#policy_seed
    - glossary.md#aspf
    - glossary.md#forest
    - glossary.md#hash_consing
    - in/in-30.md#in_in_30
doc_section_reviews:
  in_in_32:
    POLICY_SEED.md#policy_seed:
      dep_version: 1
      self_version_at_review: 6
      outcome: no_change
      note: "Reviewed POLICY_SEED.md rev1; no conflicts."
    glossary.md#aspf:
      dep_version: 1
      self_version_at_review: 6
      outcome: no_change
      note: "Gödel numbering is an implementation refinement of ASPF, not a semantic break."
    glossary.md#forest:
      dep_version: 1
      self_version_at_review: 6
      outcome: no_change
      note: "Decoration lineages extend Forest structure but preserve interning contract."
    glossary.md#hash_consing:
      dep_version: 1
      self_version_at_review: 6
      outcome: no_change
      note: "Bitmask NodeID is hash-consing applied to Gödel-numbered atoms."
    in/in-30.md#in_in_30:
      dep_version: 4
      self_version_at_review: 6
      outcome: no_change
      note: "in-30 section v4 still establishes SuiteSite as the carrier boundary; Gödel numbering remains an orthogonal representation refinement."
---

<a id="in_in_32"></a>

# in/in-32.md
## From Von Neumann to Gödel: Replacing Linear Memory with Structural Navigation

### Phased Migration to a Gödel-Numbered Execution Model

## Purpose

Define a phased migration from Gabion's current ASPF/Forest/ProjectionSpec architecture
to a Gödel-numbered execution model where:

- **NodeID** is a bitmask of semantic atoms (via prime numbering), not a tuple
- **Execution** is forest traversal + causal decoration accumulation (not pointer arithmetic)
- **Concurrency** is derived from fixed-point semantics (not explicit locks)
- **Safety** is structural (memory, code integrity, race-freedom by design)
- **Verification** is intrinsic (proofs and decorations are forest nodes)

This replaces the Von Neumann model (linear addressable memory) with the Gödel model
(canonical numbering of symbolic structures). All existing ASPF semantics are preserved;
the migration is a refinement of representation and execution, not a redesign of logic.

## Non-goals

- This step does not retire LLVM or modify the ISA.
- This step does not require a new hardware architecture.
- This step is not a single rewrite; it is layered phases with validation at each step.
- This step does not break existing ProjectionSpec queries or synthesis pipelines (adapters are provided).

## Status

**Hypothetical and non-normative workstream (prominent):** this document is
forward-looking theory and does not control implementation scope, execution policy,
or CI requirements.

`in/in-32.md` is directional architecture guidance only. Any execution/CI obligations
remain governed by [POLICY_SEED.md#policy_seed](POLICY_SEED.md#policy_seed), the
normative semantic contract in [glossary.md#contract](glossary.md#contract), and
active checklist nodes in [docs/sppf_checklist.md](docs/sppf_checklist.md).

Target architecture has a six-phase migration plan. Phases 1–3 are foundational;
Phases 4–6 build capability layers. Each phase has validation criteria; migration
is incremental and reversible at phase boundaries.

Normative pointers (explicit): [POLICY_SEED.md#policy_seed](POLICY_SEED.md#policy_seed), [glossary.md#aspf](glossary.md#aspf), [glossary.md#forest](glossary.md#forest), [glossary.md#hash_consing](glossary.md#hash_consing), [glossary.md#contract](glossary.md#contract), [CONTRIBUTING.md#contributing_contract](CONTRIBUTING.md#contributing_contract), [README.md#repo_contract](README.md#repo_contract), [AGENTS.md#agent_obligations](AGENTS.md#agent_obligations), [docs/sppf_checklist.md](docs/sppf_checklist.md), [in/in-30.md#in_in_30](in/in-30.md#in_in_30).

## Current implementation boundary

Active implementation and delivery are currently tracked in:

- [in/in-22.md](in/in-22.md)
- [in/in-30.md](in/in-30.md)
- [in/in-33.md](in/in-33.md)
- [in/in-34.md](in/in-34.md)
- [in/in-35.md](in/in-35.md)
- [in/in-36.md](in/in-36.md)
- [in/in-37.md](in/in-37.md)
- [docs/sppf_checklist.md](docs/sppf_checklist.md)

These documents define what is currently being implemented and validated. If any
statement in `in/in-32.md` appears to conflict with those active documents, treat
`in/in-32.md` as non-normative theory and follow the active implementation sources.

## Definitions

- **Atom**: A semantic component (kind, key element, metadata field, etc.).
- **Gödel numbering**: Mapping each atom to a prime ordinal; composite structures to products of primes.
- **Bitmask NodeID**: A bitmask where bit $i = 1$ iff atom $i$ is in the key.
- **Decoration**: A facet added during execution, causally scoped to execution lineages.
- **Execution lineage**: A path through the forest; decorations are scoped to descendants of the decoration event.
- **Fixed-point semantics**: Concurrent lineages rewind to LCA and merge iff operations commute.
- **Sheaf structure**: Hierarchical organization of execution lineages; gluing ensures global consistency.
- **Kolmogorov complexity**: Interning converts representation and work to information-theoretic bounds; compression equals uniqueness.

## Face / Kit / Solver

### Face (Obligations)

- **F1:** Bitmask NodeID is canonical; interning produces identical results as tuple NodeID.
- **F2:** Decoration model tracks execution state as immutable lineages, not mutable memory.
- **F3:** Interpreter executes forest bytecode without pointer arithmetic.
- **F4:** Fixed-point merging eliminates race conditions via computed synchronization.
- **F5:** Linearization to LLVM IR preserves provenance; entire pipeline is auditable.
- **F6:** Binary analysis (ELF interning) and source analysis are unified under forest structure.

### Kit (Existing machinery)

- ASPF/Forest internment and hash-consing contract (glossary.md#hash_consing)
- ProjectionSpec deterministic queries (in/in-30.md#L7)
- SuiteSite carrier (in/in-30.md#in_in_30)
- LLVM IR as linearization target
- Existing synthesis and reporting pipelines (with adapters if needed)

### Solver (Implementation plan)

**Phase 0: Preparation**
- Document atom → prime mapping for all NodeID components
- Write proof sketch: bitmask interning ≡ tuple interning (correctness)
- Design debug/serialization format (tuple remains human-readable)

**Phase 1: Gödel Numbering for NodeID (Foundation)**
- Implement atom registry and prime ordinal assignment
- Replace internal `NodeID = (kind, key_tuple)` with `NodeID = bitmask`
- Adapt hash-consing to work on bitmask canonicalization
- Validate: re-run all existing tests; verify interning results are identical
- Status check: ProjectionSpec queries still work unchanged

**Phase 2: Decoration Model (Execution State)**
- Extend Forest with `decoration_lineages` structure (DAG of facet sets)
- Implement decoration scoping (causal visibility rules)
- Add evidence tracking (lineage_id, timestamp, facet_set, parent_event)
- Implement query interface: "What decorations are visible from path P?"
- Validate: existing ProjectionSpec queries treat decorations as transparent (backward compatible)
- Status check: Forest size stable; no performance cliff

**Phase 3: Execution as Forest Traversal (Interpreter)**
- Define forest bytecode (instructions reference NodeID, not memory addresses)
- Build forest interpreter: traverse, fetch, execute via alt following
- Implement decoration on execute (add facet for executed paths)
- Implement call/return (push/pop (node, return_alt) on stack)
- Validate: simple programs execute; trace output matches expected behavior
- Status check: No pointer arithmetic in execution; all navigation is explicit

**Phase 4: Fixed-Point Merging (Concurrency)**
- Implement rewind-to-LCA algorithm for execution lineages
- Build commutativity checker for decorations
- Implement merge operation (union if commute; serialize if not)
- Nest under sheaf structure (hierarchical fork/join)
- Validate: concurrent fork/join test; verify no race conditions detected
- Status check: Synchronization emerges from semantics, not explicit locks

**Phase 5: Linearization to LLVM (Bridge)**
- Build forest → LLVM IR compiler (traversal + emission)
- Attach provenance metadata (Gödel numbers as IR comments)
- Integrate with existing LLVM JIT
- Implement reverse tracing (native code ↔ forest node mapping)
- Validate: compiled code executes; provenance trail is complete
- Status check: Entire pipeline (forest → IR → native) is auditable

**Phase 6: SuiteSite Unification + Binary Analysis (Cargo)**
- Complete Phase 1 of in/in-30.md (loop suites + deadline obligations)
- Implement bytecode interning (ELF parsing, normalization, alt emission)
- (Optional) Intern system binaries (/usr/lib/*.so for supply-chain baseline)
- Enable cross-level ProjectionSpec queries (source SuiteSite ↔ bytecode node)
- Validate: audit source + binary together; verify supply-chain attestation
- Status check: Gabion is a unified source + binary analysis platform

## Artifact Contract

- Each phase produces a validated, incrementally compatible artifact
- Existing tools remain functional (with adapters if needed)
- Forest signature stabilization confirmed by tests at each phase boundary
- Backward compatibility maintained through serialization and query compatibility layers

## Proof-by-Construction Mode

Each phase must satisfy its Face obligations via construction, not configuration.

- **Phase 1**: Proof that bitmask interning ≡ tuple interning
- **Phase 2**: Proof that decoration model preserves ProjectionSpec semantics
- **Phase 3**: Proof that forest traversal is deterministic (no pointer aliasing)
- **Phase 4**: Proof that fixed-point semantics prevents race conditions
- **Phase 5**: Proof that linearization is faithful to forest semantics
- **Phase 6**: Proof that cross-level queries preserve correctness

## Admissibility

- Each phase must not break existing ProjectionSpec, synthesis, or reporting
- Performance regressions > 10% require justification and optimization phase
- All new machinery must be deterministic and auditable

## Success Criteria

- **After Phase 1**: NodeID bitmask produces identical interning results as tuples
- **After Phase 2**: Decoration model is backward compatible with ProjectionSpec
- **After Phase 3**: Forest interpreter executes simple programs correctly
- **After Phase 4**: Fixed-point semantics prevents race conditions in concurrent fork/join
- **After Phase 5**: Forest → LLVM → native pipeline is end-to-end auditable
- **After Phase 6**: Gabion audits source + binary uniformly under forest structure

## Failure Modes and Diagnostics

- **Phase 1 failure**: Bitmask interning produces different keys than tuple interning → atom mapping is wrong
- **Phase 2 failure**: Decorations violate ProjectionSpec semantics → scoping rules are incomplete
- **Phase 3 failure**: Interpreter produces wrong output → bytecode compilation is incorrect
- **Phase 4 failure**: Race conditions detected in fixed-point merge → commutativity checker is unsound
- **Phase 5 failure**: Provenance is lost or incorrect → linearization doesn't preserve forest structure
- **Phase 6 failure**: Cross-level queries are ambiguous or lossy → SuiteSite/bytecode linkage is incomplete

## Further Considerations

### Atom Granularity
Is each metadata field a separate atom, or are atoms grouped by semantic domain?
Impacts bitmask size and allocation strategy.

### Serialization Format
Debug/human-readable tuples are retained for YAML/JSON; bitmask is internal representation.
How do you validate round-trip fidelity?

### Performance Model
Rewind-and-merge overhead for fork/join is explicit; where is the acceptable threshold?
Measured as function of contention rate.

### Proof Automation
Are proofs for each phase manually written, or derived from the forest structure itself?

### LLVM as Target
Do you keep LLVM as the final target, or use Gödel-numbered forest as the canonical ISA?

### Bootstrapping
How is the forest interpreter itself compiled?
Self-hosted via Phase 5, or external?

### Interning and Kolmogorov Complexity
Interning converts all representation cost to the uniqueness of inputs.
For large binaries (e.g., /usr/lib/*.so), what is the expected compression ratio?
Does lazy interning (defer normalization until queried) improve amortized cost?

## Paper Draft: Finite-Carrier Term-Graph Calculus

### Title
Finite-Carrier Term-Graph Calculus with Interning: A Canonical Semantics for Gabion

### Abstract (Draft)
We present a finite-carrier term-graph calculus in which construction and
interning coincide with evaluation. Nodes are interned by canonicalization
(hash-consing), alts encode derivations, and evidence records provenance. We
define a bitmask NodeID encoding over a finite atom set and show that
normalization is deterministic and idempotent, that equivalence is decidable by
interned identity, and that quantification over the carrier reduces to finite
conjunction/disjunction. The calculus provides a canonical semantic core for
Gabion, enabling deterministic projections, audit stability, and proof-carrying
analysis.

### 1. Introduction (Draft)
Linear-memory models conflate identity with address and permit arithmetic
across semantic boundaries. We replace this with a finite-carrier term-graph
semantics in which all objects live in a canonical, interned space. Interning
is not a digest; it is the normalized representative of a term. This yields
determinism, auditability, and extensional equivalence by identity.

**Contributions.**
1. A finite-carrier term-graph calculus with interned identities.
2. A bitmask NodeID encoding over atom registries.
3. Deterministic evaluation by construction + normalization.
4. Decidable equivalence and finite quantification over carriers.
5. A direct mapping to Gabion’s ASPF/Forest/ProjectionSpec stack.

**Outline.** Section 2 defines syntax, Section 3 semantics, Section 4 properties,
Section 5 computation model, Section 6 the mapping to Gabion, and Sections 7–8
limitations and future work.

### 2. Syntax (Draft)
Let $\mathbb{A}$ be a finite set of atoms. Let $\mathbb{K}$ be a finite set of
alt kinds and $\mathbb{V}$ a set of evidence values.

**Atom registry.** A total injective map $\rho : \mathbb{A} \to \mathbb{N}$ assigns
ordinals to atoms. A NodeID is the bitmask of its atom set.

**Grammar.**
- **NodeID**: $n ::= \bigcup_{i=1}^k a_i$.
- **Meta**: $m ::= \{ (k_i, v_i) \}_{i=1}^p$ (finite map).
- **Node**: $\mathrm{node}(n, m)$.
- **Alt**: $\mathrm{alt}(k, \langle n_1,\dots,n_m\rangle, e)$ where $k\in\mathbb{K}$,
  $e\in\mathbb{V}$.
- **Forest**: $F ::= (N, A)$ with $N$ a finite set of Nodes and $A$ a finite set
  of Alts.

**Bitmask encoding.** For atom $a$, define bit position $\rho(a)$. The NodeID
for atom set $S \subseteq \mathbb{A}$ is the bitmask $\mathrm{mask}(S)$ where the
$\rho(a)$th bit is 1 iff $a\in S$.

### 3. Semantics (Draft)
Let $\Rightarrow$ be a normalization relation on terms with normal form
$\operatorname{nf}(t)$. Interning is normalization:

$$
\operatorname{intern}(t) = \operatorname{nf}(t),
\quad
\operatorname{intern}(\operatorname{intern}(t)) = \operatorname{intern}(t).
$$

**Evaluation.** Construction followed by interning:

$$
t \Downarrow \operatorname{intern}(t).
$$

**Forest well-formedness.** A forest $F=(N,A)$ is well-formed when every
NodeID referenced in alts appears in $N$, and all meta maps are finite.

**Admissibility.** Evidence is an uninterpreted payload in this core calculus;
admissibility constraints are added by instantiated carriers (e.g., SuiteSite
or policy facets) without changing the core semantics.

### 3.1 Judgments (Draft)
We use the following judgments:

- $F \vdash n$ : NodeID $n$ is present in forest $F$.
- $F \vdash \mathrm{alt}(k,\vec{n},e)$ : alt is present in $F$ with inputs $\vec{n}$.
- $F \vdash t \Downarrow n$ : term $t$ evaluates to NodeID $n$ under interning.
- $F \vdash \langle n, \mathcal{E} \rangle \to \langle n', \mathcal{E}' \rangle$ : execution step.

### 3.2 Inference Rules (Draft)

**Interning rule.**

$$
\frac{\operatorname{nf}(t)=n}{F \vdash t \Downarrow n}
$$

**Alt traversal.**

$$
\frac{\mathrm{alt}(k,\langle n,n'\rangle,e)\in A}{F \vdash \langle n,\mathcal{E} \rangle \to \langle n',\mathcal{E}\cup\{e\} \rangle}
$$

**Forest membership.**

$$
\frac{\mathrm{node}(n,m)\in N}{F \vdash n}
$$

These are schematic: specific carriers add admissibility predicates to alts
but do not alter the core rules.

### 4. Properties (Draft)
Assuming a terminating, confluent normalization system:

- **Uniqueness**: each term has a unique interned representative.
- **Idempotence**: interning is idempotent by construction.
- **Decidable equivalence**: $t \equiv u$ iff $\operatorname{intern}(t)=\operatorname{intern}(u)$.
- **Finite quantification**: for carrier $D$, $\forall x\,\varphi(x)$ reduces to
  $\bigwedge_{a\in D} \varphi(a)$ and $\exists x\,\varphi(x)$ to
  $\bigvee_{a\in D} \varphi(a)$.

**Proof sketch (Uniqueness).** Confluence yields a unique normal form
$\operatorname{nf}(t)$ for every term; interning returns this normal form.

**Proof sketch (Decidable equivalence).** Since interning is total and
computable, compute $\operatorname{intern}(t)$ and $\operatorname{intern}(u)$ and
compare NodeIDs.

### 4.1 Proof Obligations (Draft)
To lift the core calculus to an instantiated carrier, provide:

1. **Termination** of the carrier’s normalization rules.
2. **Confluence** of the normalization rules.
3. **Finite carrier emission** (explicit enumeration of carrier domain).
4. **Admissibility predicates** that preserve determinism of alt selection.

### 4.2 Theorem Statements (Draft)

**Theorem 4.2.1 (Uniqueness of Interning).** If normalization is terminating and
confluent, then for all terms $t$ there exists a unique $n$ such that
$t \Downarrow n$.

**Theorem 4.2.2 (Extensional Equivalence).** For all terms $t,u$, $t\equiv u$ iff
$\operatorname{intern}(t)=\operatorname{intern}(u)$.

**Theorem 4.2.3 (Finite Quantification).** For a finite carrier $D$, the
quantifiers $\forall$ and $\exists$ reduce to finite conjunction/disjunction
over $D$.

### 5. Computation Model (Draft)
Computation proceeds by traversing alts and accumulating evidence as facets.
State is the pair $(n, \mathcal{E})$ where $n$ is the current NodeID and
$\mathcal{E}$ is the visible evidence set.

**Transition rule (schematic).** If $\mathrm{alt}(k,\langle n, n'\rangle, e)\in A$,
then:

$$
\langle n, \mathcal{E} \rangle \to \langle n', \mathcal{E}\cup\{e\} \rangle.
$$

Determinism is ensured by the normalization system and a deterministic alt
selection policy; nondeterminism is represented explicitly as multiple alts.

### 5.1 Determinism Conditions (Draft)
Determinism holds when:

1. Normalization is deterministic (unique normal form).
2. Alt selection is deterministic for a given state, or nondeterminism is
  represented as explicit, enumerable branching (multiple alts).
3. Evidence accumulation is monotone (no deletions).

### 6. Relation to Gabion (Draft)
Gabion’s ASPF is the root carrier; the Forest is its materialized graph.
SuiteSites provide locality; ProjectionSpec is elimination over finite carriers.
This calculus provides the canonical semantics that make those layers
deterministic and audit-stable. Mapping:

- **Atom registry** ↔ ASPF carriers and normalization rules.
- **NodeID bitmask** ↔ hash-consed identity for Forest nodes.
- **Alt evidence** ↔ facet and witness payloads.
- **Transition rules** ↔ traversal in analysis passes and synthesis.
- **Finite quantification** ↔ ProjectionSpec counterexample/witness projections.

### 7. Limitations (Draft)
- Normalization must be designed to be terminating and confluent.
- Carrier finiteness must be explicit; unbounded carriers require staged emission.
- Performance depends on interning and query indices rather than mutation.
- External effects must be reified as facets or remain outside the calculus.

### 7.1 Threats to Validity (Draft)
- Hidden non-determinism in normalization (e.g., unordered maps).
- Implicit carrier expansion at runtime (violates finite-domain assumptions).
- Evidence mutation or deletion (breaks monotonicity).

### 8. Future Work (Draft)
- Fixed-point merge semantics for concurrent lineages.
- Gödel-numbered NodeID bitmask encoding and compression bounds.
- Verified linearization to LLVM IR with provenance guarantees.
- Bytecode interning as SuiteSite/block carriers.

## Appendix A: Phase Dependencies and Gates

```
Phase 0 (Prep)
 └── Phase 1 (Bitmask NodeID) [gate: interning equivalence proof]
      └── Phase 2 (Decoration) [gate: ProjectionSpec backward compat]
           └── Phase 3 (Interpreter) [gate: simple programs execute]
                └── Phase 4 (Fixed-Point) [gate: no race conditions]
                     └── Phase 5 (Linearization) [gate: auditable pipeline]
                          └── Phase 6 (Binary Analysis) [gate: cross-level correctness]
```

No parallel phases; each phase depends on validation of the previous.

## Appendix B: Glossary Extensions

**Gödel numbering**: Canonical assignment of primes to semantic atoms; composite structures are products of primes.

**Bitmask NodeID**: Representation of a canonical structure as a bitmask where bit $i$ indicates presence of atom $i$.

**Decoration lineage**: Causal ordering of execution paths; decorations are scoped to descendants of decoration events.

**Fixed-point semantics**: Merging of concurrent lineages via commutativity checking; non-commutative operations enforce ordering.

**Sheaf gluing**: Hierarchical merge semantics for nested fork/join; local fixed-points are compatible globally.

**Security-module-grade safety**: Safety properties that cannot be violated by any implementation detail or attack; enforced structurally, not configurably.
