---
doc_revision: 2
reader_reintern: "Reader-only: re-intern if doc_revision changed since you last read this doc."
doc_id: in_32
doc_role: in_step
doc_scope:
  - repo
  - architecture
  - execution-model
  - concurrency
  - verification
doc_authority: informative
doc_owner: maintainer
doc_requires:
  - POLICY_SEED.md#policy_seed
  - glossary.md#aspf
  - glossary.md#forest
  - glossary.md#hash_consing
  - CONTRIBUTING.md#contributing_contract
  - README.md#repo_contract
  - AGENTS.md#agent_obligations
  - in/in-30.md#in_in_30
doc_reviewed_as_of:
  POLICY_SEED.md#policy_seed: 1
  glossary.md#aspf: 1
  glossary.md#forest: 1
  glossary.md#hash_consing: 1
  CONTRIBUTING.md#contributing_contract: 1
  README.md#repo_contract: 1
  AGENTS.md#agent_obligations: 1
  in/in-30.md#in_in_30: 1
doc_review_notes:
  POLICY_SEED.md#policy_seed: "Reviewed POLICY_SEED.md rev1 (mechanized governance); no conflicts with this document's scope."
  glossary.md#aspf: "Reviewed glossary.md#aspf rev1 (ASPF carrier semantics); this document extends ASPF with Gödel numbering and decoration lineages."
  glossary.md#forest: "Reviewed glossary.md#forest rev1 (Forest materialized carrier); compatible with extended decoration model."
  glossary.md#hash_consing: "Reviewed glossary.md#hash_consing rev1 (hash-consing internment); Gödel numbering is a refinement, not a break."
  CONTRIBUTING.md#contributing_contract: "Reviewed CONTRIBUTING.md rev1; no conflicts."
  README.md#repo_contract: "Reviewed README.md rev1; phased migration preserves existing tooling."
  AGENTS.md#agent_obligations: "Reviewed AGENTS.md rev1; agent must enforce determinism and correctness at each phase."
  in/in-30.md#in_in_30: "Reviewed in/in-30.md rev24 (SuiteSite unification); this document builds on SuiteSite + Forest as the foundation."
doc_change_protocol: "POLICY_SEED.md#change_protocol"
doc_erasure:
  - spelling/formatting only
  - reflow without semantic edits
doc_sections:
  in_in_32: 2
doc_section_requires:
  in_in_32:
    - POLICY_SEED.md#policy_seed
    - glossary.md#aspf
    - glossary.md#forest
    - glossary.md#hash_consing
    - in/in-30.md#in_in_30
doc_section_reviews:
  in_in_32:
    POLICY_SEED.md#policy_seed:
      dep_version: 1
      self_version_at_review: 2
      outcome: no_change
      note: "Reviewed POLICY_SEED.md rev1; no conflicts."
    glossary.md#aspf:
      dep_version: 1
      self_version_at_review: 2
      outcome: no_change
      note: "Gödel numbering is an implementation refinement of ASPF, not a semantic break."
    glossary.md#forest:
      dep_version: 1
      self_version_at_review: 2
      outcome: no_change
      note: "Decoration lineages extend Forest structure but preserve interning contract."
    glossary.md#hash_consing:
      dep_version: 1
      self_version_at_review: 2
      outcome: no_change
      note: "Bitmask NodeID is hash-consing applied to Gödel-numbered atoms."
    in/in-30.md#in_in_30:
      dep_version: 1
      self_version_at_review: 2
      outcome: no_change
      note: "SuiteSite carrier is the base for all phases; Gödel numbering is orthogonal."
---

<a id="in_in_32"></a>

# in/in-32.md
## From Von Neumann to Gödel: Replacing Linear Memory with Structural Navigation

### Phased Migration to a Gödel-Numbered Execution Model

## Purpose

Define a phased migration from Gabion's current ASPF/Forest/ProjectionSpec architecture
to a Gödel-numbered execution model where:

- **NodeID** is a bitmask of semantic atoms (via prime numbering), not a tuple
- **Execution** is forest traversal + causal decoration accumulation (not pointer arithmetic)
- **Concurrency** is derived from fixed-point semantics (not explicit locks)
- **Safety** is structural (memory, code integrity, race-freedom by design)
- **Verification** is intrinsic (proofs and decorations are forest nodes)

This replaces the Von Neumann model (linear addressable memory) with the Gödel model
(canonical numbering of symbolic structures). All existing ASPF semantics are preserved;
the migration is a refinement of representation and execution, not a redesign of logic.

## Non-goals

- This step does not retire LLVM or modify the ISA.
- This step does not require a new hardware architecture.
- This step is not a single rewrite; it is layered phases with validation at each step.
- This step does not break existing ProjectionSpec queries or synthesis pipelines (adapters are provided).

## Status

Hypothetical and non-normative workstream. This document is acknowledged as a
forward-looking exploration and does not control implementation, policy, or CI.
Target architecture has a six-phase migration plan. Phases 1–3 are foundational;
Phases 4–6 build capability layers. Each phase has validation criteria; migration
is incremental and reversible at phase boundaries.

Normative pointers (explicit): [POLICY_SEED.md#policy_seed](POLICY_SEED.md#policy_seed), [glossary.md#aspf](glossary.md#aspf), [glossary.md#forest](glossary.md#forest), [glossary.md#hash_consing](glossary.md#hash_consing), [CONTRIBUTING.md#contributing_contract](CONTRIBUTING.md#contributing_contract), [README.md#repo_contract](README.md#repo_contract), [AGENTS.md#agent_obligations](AGENTS.md#agent_obligations), [in/in-30.md#in_in_30](in/in-30.md#in_in_30).

## Definitions

- **Atom**: A semantic component (kind, key element, metadata field, etc.).
- **Gödel numbering**: Mapping each atom to a prime ordinal; composite structures to products of primes.
- **Bitmask NodeID**: A bitmask where bit $i = 1$ iff atom $i$ is in the key.
- **Decoration**: A facet added during execution, causally scoped to execution lineages.
- **Execution lineage**: A path through the forest; decorations are scoped to descendants of the decoration event.
- **Fixed-point semantics**: Concurrent lineages rewind to LCA and merge iff operations commute.
- **Sheaf structure**: Hierarchical organization of execution lineages; gluing ensures global consistency.
- **Kolmogorov complexity**: Interning converts representation and work to information-theoretic bounds; compression equals uniqueness.

## Face / Kit / Solver

### Face (Obligations)

- **F1:** Bitmask NodeID is canonical; interning produces identical results as tuple NodeID.
- **F2:** Decoration model tracks execution state as immutable lineages, not mutable memory.
- **F3:** Interpreter executes forest bytecode without pointer arithmetic.
- **F4:** Fixed-point merging eliminates race conditions via computed synchronization.
- **F5:** Linearization to LLVM IR preserves provenance; entire pipeline is auditable.
- **F6:** Binary analysis (ELF interning) and source analysis are unified under forest structure.

### Kit (Existing machinery)

- ASPF/Forest internment and hash-consing contract (glossary.md#hash_consing)
- ProjectionSpec deterministic queries (in/in-30.md#L7)
- SuiteSite carrier (in/in-30.md#in_in_30)
- LLVM IR as linearization target
- Existing synthesis and reporting pipelines (with adapters if needed)

### Solver (Implementation plan)

**Phase 0: Preparation**
- Document atom → prime mapping for all NodeID components
- Write proof sketch: bitmask interning ≡ tuple interning (correctness)
- Design debug/serialization format (tuple remains human-readable)

**Phase 1: Gödel Numbering for NodeID (Foundation)**
- Implement atom registry and prime ordinal assignment
- Replace internal `NodeID = (kind, key_tuple)` with `NodeID = bitmask`
- Adapt hash-consing to work on bitmask canonicalization
- Validate: re-run all existing tests; verify interning results are identical
- Status check: ProjectionSpec queries still work unchanged

**Phase 2: Decoration Model (Execution State)**
- Extend Forest with `decoration_lineages` structure (DAG of facet sets)
- Implement decoration scoping (causal visibility rules)
- Add evidence tracking (lineage_id, timestamp, facet_set, parent_event)
- Implement query interface: "What decorations are visible from path P?"
- Validate: existing ProjectionSpec queries treat decorations as transparent (backward compatible)
- Status check: Forest size stable; no performance cliff

**Phase 3: Execution as Forest Traversal (Interpreter)**
- Define forest bytecode (instructions reference NodeID, not memory addresses)
- Build forest interpreter: traverse, fetch, execute via alt following
- Implement decoration on execute (add facet for executed paths)
- Implement call/return (push/pop (node, return_alt) on stack)
- Validate: simple programs execute; trace output matches expected behavior
- Status check: No pointer arithmetic in execution; all navigation is explicit

**Phase 4: Fixed-Point Merging (Concurrency)**
- Implement rewind-to-LCA algorithm for execution lineages
- Build commutativity checker for decorations
- Implement merge operation (union if commute; serialize if not)
- Nest under sheaf structure (hierarchical fork/join)
- Validate: concurrent fork/join test; verify no race conditions detected
- Status check: Synchronization emerges from semantics, not explicit locks

**Phase 5: Linearization to LLVM (Bridge)**
- Build forest → LLVM IR compiler (traversal + emission)
- Attach provenance metadata (Gödel numbers as IR comments)
- Integrate with existing LLVM JIT
- Implement reverse tracing (native code ↔ forest node mapping)
- Validate: compiled code executes; provenance trail is complete
- Status check: Entire pipeline (forest → IR → native) is auditable

**Phase 6: SuiteSite Unification + Binary Analysis (Cargo)**
- Complete Phase 1 of in/in-30.md (loop suites + deadline obligations)
- Implement bytecode interning (ELF parsing, normalization, alt emission)
- (Optional) Intern system binaries (/usr/lib/*.so for supply-chain baseline)
- Enable cross-level ProjectionSpec queries (source SuiteSite ↔ bytecode node)
- Validate: audit source + binary together; verify supply-chain attestation
- Status check: Gabion is a unified source + binary analysis platform

## Artifact Contract

- Each phase produces a validated, incrementally compatible artifact
- Existing tools remain functional (with adapters if needed)
- Forest signature stabilization confirmed by tests at each phase boundary
- Backward compatibility maintained through serialization and query compatibility layers

## Proof-by-Construction Mode

Each phase must satisfy its Face obligations via construction, not configuration.

- **Phase 1**: Proof that bitmask interning ≡ tuple interning
- **Phase 2**: Proof that decoration model preserves ProjectionSpec semantics
- **Phase 3**: Proof that forest traversal is deterministic (no pointer aliasing)
- **Phase 4**: Proof that fixed-point semantics prevents race conditions
- **Phase 5**: Proof that linearization is faithful to forest semantics
- **Phase 6**: Proof that cross-level queries preserve correctness

## Admissibility

- Each phase must not break existing ProjectionSpec, synthesis, or reporting
- Performance regressions > 10% require justification and optimization phase
- All new machinery must be deterministic and auditable

## Success Criteria

- **After Phase 1**: NodeID bitmask produces identical interning results as tuples
- **After Phase 2**: Decoration model is backward compatible with ProjectionSpec
- **After Phase 3**: Forest interpreter executes simple programs correctly
- **After Phase 4**: Fixed-point semantics prevents race conditions in concurrent fork/join
- **After Phase 5**: Forest → LLVM → native pipeline is end-to-end auditable
- **After Phase 6**: Gabion audits source + binary uniformly under forest structure

## Failure Modes and Diagnostics

- **Phase 1 failure**: Bitmask interning produces different keys than tuple interning → atom mapping is wrong
- **Phase 2 failure**: Decorations violate ProjectionSpec semantics → scoping rules are incomplete
- **Phase 3 failure**: Interpreter produces wrong output → bytecode compilation is incorrect
- **Phase 4 failure**: Race conditions detected in fixed-point merge → commutativity checker is unsound
- **Phase 5 failure**: Provenance is lost or incorrect → linearization doesn't preserve forest structure
- **Phase 6 failure**: Cross-level queries are ambiguous or lossy → SuiteSite/bytecode linkage is incomplete

## Further Considerations

### Atom Granularity
Is each metadata field a separate atom, or are atoms grouped by semantic domain?
Impacts bitmask size and allocation strategy.

### Serialization Format
Debug/human-readable tuples are retained for YAML/JSON; bitmask is internal representation.
How do you validate round-trip fidelity?

### Performance Model
Rewind-and-merge overhead for fork/join is explicit; where is the acceptable threshold?
Measured as function of contention rate.

### Proof Automation
Are proofs for each phase manually written, or derived from the forest structure itself?

### LLVM as Target
Do you keep LLVM as the final target, or use Gödel-numbered forest as the canonical ISA?

### Bootstrapping
How is the forest interpreter itself compiled?
Self-hosted via Phase 5, or external?

### Interning and Kolmogorov Complexity
Interning converts all representation cost to the uniqueness of inputs.
For large binaries (e.g., /usr/lib/*.so), what is the expected compression ratio?
Does lazy interning (defer normalization until queried) improve amortized cost?

## Appendix A: Phase Dependencies and Gates

```
Phase 0 (Prep)
 └── Phase 1 (Bitmask NodeID) [gate: interning equivalence proof]
      └── Phase 2 (Decoration) [gate: ProjectionSpec backward compat]
           └── Phase 3 (Interpreter) [gate: simple programs execute]
                └── Phase 4 (Fixed-Point) [gate: no race conditions]
                     └── Phase 5 (Linearization) [gate: auditable pipeline]
                          └── Phase 6 (Binary Analysis) [gate: cross-level correctness]
```

No parallel phases; each phase depends on validation of the previous.

## Appendix B: Glossary Extensions

**Gödel numbering**: Canonical assignment of primes to semantic atoms; composite structures are products of primes.

**Bitmask NodeID**: Representation of a canonical structure as a bitmask where bit $i$ indicates presence of atom $i$.

**Decoration lineage**: Causal ordering of execution paths; decorations are scoped to descendants of decoration events.

**Fixed-point semantics**: Merging of concurrent lineages via commutativity checking; non-commutative operations enforce ordering.

**Sheaf gluing**: Hierarchical merge semantics for nested fork/join; local fixed-points are compatible globally.

**Security-module-grade safety**: Safety properties that cannot be violated by any implementation detail or attack; enforced structurally, not configurably.
