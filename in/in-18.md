# in-18: Algebraic Decision Surfaces and Value-Encoded Control Detection

## Problem

In branchless programming styles—common in security-sensitive code, SIMD-optimized code, and performance-critical routines—conditional behavior is encoded through arithmetic operations such as `min`, `max`, multiplication with boolean-like expressions, and bitmasking. These structures intentionally avoid explicit branching for performance or timing side-channel reasons.

While effective, this approach creates a **semantic opacity** problem: control flow exists, but is no longer syntactically exposed. This causes Gabion’s standard grammar and decision-surface analysis to miss critical structural boundaries, tier violations, or glossary-aligned decision points.

## Goals

* Detect value-encoded decision surfaces in algebraic or branchless constructs.
* Restore implicit control structure as a first-class analysis artifact.
* Warn on tiered glossary term use within nonlinear constructs.
* Enable refactor output to optionally “rebranch” such logic for clarity.

## Proposed Approach

1. **Extend Grammar Analysis with Nonlinear Decision Heuristics**

   * Introduce `is_value_encoded_decision(node: Expr) -> bool` in grammars.
   * Detect patterns like:

     * `min(a, b)`
     * `a * (cond)` or `b + (flag * delta)`
     * `(cond & mask)` or `(cond << shift)`
   * Flag expressions where conditional influence is algebraically embedded.

2. **Integrate Glossary Awareness**

   * If glossary keys appear in nonlinear contexts (e.g. `security_mode` in `*`, `//`, etc.), surface a semantic warning.
   * Allow glossary tier rules to apply regardless of syntactic structure.

3. **Emit Rebranch Suggestions**

   * Synthesis pass can optionally emit equivalent `if`-based logic for human readability (configurable).
   * Useful in documentation contexts or early-stage refactor reviews.

4. **Audit Trail and Diff Support**

   * Allow value-encoded decision points to be surfaced in CI grammar reports.
   * Enable tracking of added/removed nonlinear control regions across commits.

## Example

Code:

```python
a = (user_mode == "admin") * elevated_value + (user_mode != "admin") * normal_value
```

Gabion emits:

```
✓ Detected value-encoded decision surface using 'user_mode'
✓ Tier 2 glossary term 'user_mode' used in nonlinear conditional context
✓ Suggest refactoring to explicit branch for clarity or boundary elevation
```

Optional rewrite:

```python
if user_mode == "admin":
    a = elevated_value
else:
    a = normal_value
```

## Dependencies

* Expression grammar access (e.g. `Expr` tree node types)
* Glossary tier enforcement engine (from in-15)
* Optional: rewrite engine or expression normalizer

## Acceptance Criteria

* Grammar detects at least one min/max or bitmask-based control flow
* Glossary term tier violation surfaces even without `if`
* CLI flag enables value-decision audit or refactor synthesis
* CI output shows value-encoded surface count and location

---

Proposed by: branchless audit discussion
Related: in-15 (tiered surfaces), in-16 (diffing), in-17 (subtree reuse)
Status: draft
