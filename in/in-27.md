---
doc_revision: 1
reader_reintern: "Reader-only: re-intern if doc_revision changed since you last read this doc."
doc_id: in_27
doc_role: in_step
doc_scope:
  - repo
  - tooling
  - research
  - semantics
doc_authority: normative
doc_requires:
  - POLICY_SEED.md
  - glossary.md
  - CONTRIBUTING.md
  - README.md
  - in/in-23.md
  - in/in-24.md
  - in/in-25.md
  - in/in-26.md
  - out/out-3.md
doc_reviewed_as_of:
  POLICY_SEED.md: 28
  glossary.md: 17
  CONTRIBUTING.md: 71
  README.md: 58
  in/in-23.md: 1
  in/in-24.md: 3
  in/in-25.md: 3
  in/in-26.md: 3
  out/out-3.md: 3
doc_change_protocol: "POLICY_SEED.md §6"
doc_erasure:
  - formatting
  - typos
doc_owner: maintainer
---

# in/in-27.md

## Exception-Safety by Construction

### “All Exception Paths Are Dead or Handled” as a Refactoring Obligation

---

## 0. Status

**Scope: elevate exception behavior into the same evidence regime as carriers, deadness, and coherence.**

* `in-23`–`in-25` establish an evidence-complete attribute-grammar view of the codebase:

  * boundary semantics (provenance),
  * emptiness (deadness),
  * branching coherence (horn fillers),
  * with reproducible synth bases.
* `in-26` converts evidence into **proof-carrying rewrite plans** whose acceptance requires re-audit invariants.

This step introduces a specific, high-leverage correctness objective:

> **Every exception path must be proven unreachable (dead) or proven handled.**

This coerces refactoring toward correctness-by-construction: exception behavior is not allowed to remain an implicit runtime escape hatch.

---

## 1. Goal

Define and enforce an **Exception Obligation** framework such that:

1. Exception paths are **enumerated** deterministically.
2. Each exception path is discharged by:

   * a `DeadnessWitness` (unreachable under admitted environments), or
   * a `HandlednessWitness` (caught/converted into a declared outcome).
3. Any undischargeable or unknown exception path blocks acceptance of rewrite plans and/or blocks “green” audit status.

This step is normative: it defines what counts as “exception-safe by construction” for the repo.

---

## 2. Definitions (minimal, repo-native)

### 2.1 ExceptionPath

An **ExceptionPath** is a syntactic or semantic execution path that may raise/throw an exception (or equivalent failure) at runtime.

This step defines a staged taxonomy of exception sources:

**E0 — Explicit exception sites**

* `raise`, `throw`, `panic`, `assert`-failure sites, explicit `Error(...)` returns if treated as exceptions by policy.

**E1 — Known exception-throwing primitives**

* operations known to throw under precondition failure (e.g., index/key access, numeric conversions), as determined by a repo-maintained list.

**E2 — Declared exception contracts**

* user/library calls annotated as “may throw” or “may fail,” optionally inferred from stubs.

The repo may initially implement only E0 and expand later; the obligation framework must not assume completeness beyond the enabled set.

### 2.2 Admitted environment domain

Deadness is only meaningful relative to a domain of admissible environments.

This step defines the **domain-of-use boundary** as:

* the set of environments induced by the analysis entrypoints used by the audit pipeline, plus any declared preconditions.

Normative rule:

* deadness witnesses must explicitly name the environment assumptions used to prove deadness.
* if an exception is dead only under a stronger precondition, the precondition must be declared and referenced.

### 2.3 Discharge witnesses

**DeadnessWitness** (already defined in `in-24`):
evidence that the exception path is unreachable under a specific environment.

**HandlednessWitness** (new):
evidence that the exception is caught, converted, or otherwise discharged into a declared outcome under all admissible executions reaching the site.

Minimal handledness evidence fields:

* `site`: `(path, function, bundle)`
* `exception_path_id` (stable key)
* `handler_kind`: `catch|guard|convert|totalize`
* `handler_boundary`: what outcome replaces the exception (e.g., Result/Option, error value, logged abort)
* `environment`: any assumptions required (should be empty for true handling; if not empty, it is a constrained handling case)
* `core`: reduced trail demonstrating the handler dominates the exception site

### 2.4 Exception obligation entry

An **ExceptionObligation** binds an ExceptionPath to its discharge status:

* `exception_path_id`
* `site`
* `source_kind` (E0/E1/E2)
* `status`: `DEAD|HANDLED|UNKNOWN`
* `witness_ref`: reference into deadness/handledness artifacts
* `remainder`: explicit if analysis cannot fully model the exception path

### 2.5 Exception artifact

`fingerprint_exception_obligations.json` is the serialized list of ExceptionObligation entries.

This is the exception-safety sibling of:

* `fingerprint_deadness.json`
* `fingerprint_provenance.json`
* `fingerprint_coherence.json`
* `fingerprint_rewrite_plans.json`

---

## 3. Principle: exceptions are not allowed to remain semantic ambiguity

Under this policy:

* exceptions are not “acceptable unknown behavior,”
* they are proof obligations.

The system may still contain exception-throwing code, but it must be:

* unreachable (dead), or
* dominated by a handler (handled).

Any remaining exception path is an explicit `UNKNOWN` obligation and must be surfaced.

---

## 4. Face / Kit / Solver (repo idiom)

### 4.1 Face (obligations)

**X1 — Enumeration completeness (relative to enabled taxonomy)**
All E0 exception sites must be enumerated. E1/E2 enumeration is required only if enabled.

**X2 — Discharge completeness**
Every enumerated ExceptionPath must be discharged as `DEAD` or `HANDLED`, or explicitly marked `UNKNOWN` with remainder.

**X3 — Evidence requirement**
`DEAD` requires a DeadnessWitness; `HANDLED` requires a HandlednessWitness. No discharge without artifact.

**X4 — Non-conflation**
`UNKNOWN` must not be treated as discharged. It blocks acceptance where configured.

**X5 — Determinism**
Obligations and their ordering must be deterministic across runs.

**X6 — Snapshot reproducibility**
Exception obligation artifacts must be snapshot-captured and discoverable via latest selectors.

**X7 — Refactoring coercion**
Rewrite plans that claim to improve correctness must not be accepted if they increase the count of `UNKNOWN` exception obligations.

### 4.2 Kit (available machinery)

From prior steps:

* deadness witness framework (`in-24`)
* coherence framework (`in-25`) for ambiguous control-flow paths
* rewrite plan framework (`in-26`)
* stable surface anchors (path/function/bundle)
* artifact emission plumbing and snapshot tooling patterns

New kit to add (minimal):

* exception site enumeration pass (start with E0)
* handler dominance detection (for handledness witnesses)

### 4.3 Solver (how obligations are discharged)

#### Phase A — Enumerate exception paths

* enumerate E0 sites deterministically
* optionally enumerate E1/E2 based on configured lists/contracts
* assign stable `exception_path_id` (hash of site + source kind + local signature)

#### Phase B — Attempt deadness discharge

* reuse deadness analysis to prove unreachable exception paths
* emit DeadnessWitness references for discharged paths

#### Phase C — Attempt handledness discharge

* detect handler dominance or conversion
* emit HandlednessWitness references

#### Phase D — Emit obligations artifact

* emit `fingerprint_exception_obligations.json`
* report section **Exception obligations**
* plumb via CLI + LSP
* snapshot capture + latest selector

This is consistent with the evidence-first pipeline: enumeration produces obligations, and discharge produces witnesses.

---

## 5. Artifact contract

### 5.1 Required artifact (when enabled)

* `fingerprint_exception_obligations.json`
* report section: **Exception obligations**
* LSP field: `fingerprint_exception_obligations` (or equivalent)

### 5.2 Schema obligations (normative, minimal)

Each entry must include:

* `exception_path_id`
* `site`: `path`, `function`, `bundle`
* `source_kind`: `E0|E1|E2`
* `status`: `DEAD|HANDLED|UNKNOWN`
* `witness_ref` (or null only if UNKNOWN)
* `remainder` (required if UNKNOWN)
* `environment_ref` (either inline or reference to deadness/handledness witness environment)

Ordering:

* sort by `(path, function, bundle, source_kind, exception_path_id)`.

---

## 6. Verification predicates (extends `in-26`)

A rewrite plan is accepted only if, post-rewrite:

**XV1 — Non-regression**

* the number of `UNKNOWN` exception obligations does not increase
* the number of `DEAD+HANDLED` obligations does not decrease

**XV2 — Prefer progress**

* where the rewrite claims correctness improvement, at least one `UNKNOWN → DEAD|HANDLED` transition must occur

**XV3 — Witness validity**

* all referenced deadness/handledness witnesses remain replayable and deterministic under pinned basis/environment

**XV4 — Coherence consistency**

* where coherence witnesses were needed to explain exception path alternatives, those witnesses remain available or are made unnecessary by strengthened determinism (explicitly recorded)

This ties exception correctness into the proof-carrying rewrite framework.

---

## 7. Snapshot integration (required)

Extend snapshot tooling:

* `audit_snapshot.sh` captures `fingerprint_exception_obligations.json` when enabled
* `latest_snapshot.sh` adds selector `--fingerprint-exception-obligations`
* artifacts must be listed by default when present

This ensures exception correctness is audited like any other semantic invariant.

---

## 8. Checks as lemmas (tests → obligations)

Introduce tests analogous to earlier steps:

* **Enumeration test** (X1):

  * fixture with explicit `raise`/assert path → obligation emitted

* **Deadness discharge test** (X2/X3):

  * fixture where exception is provably unreachable under constant propagation → status DEAD with witness

* **Handledness discharge test** (X2/X3):

  * fixture where exception is caught/converted → status HANDLED with witness

* **Unknown stability test** (X4/X5):

  * fixture where discharge cannot be proven → status UNKNOWN with remainder, deterministic output

* **Rewrite acceptance regression test** (XV1):

  * simulated rewrite that introduces new exception path without witness must fail acceptance predicate

Docflow audit remains required.

---

## 9. Relation to attribute grammar and correctness-by-construction

This step makes a strong interpretive shift, but it is operational:

* exceptions correspond to paths that exit the admissible semantic fiber
* discharging exceptions is proving those paths are empty (dead) or redirected into the fiber (handled)

Thus, the exception obligation is a refinement of the inherited-attribute regime:

* it requires that the inherited environment be sufficient to rule out (or dominate) exceptional behavior

This is “correctness by construction” in the precise sense:

* the program is accepted only when exceptional behavior has no inhabitants in the admitted semantics.

---

## 10. Minimal success criteria

This step is complete when:

1. Exception obligations are emitted as a deterministic JSON artifact and snapshot-captured.
2. E0 enumeration is complete and tested.
3. DEAD/HANDLED discharges require explicit witnesses; UNKNOWN is explicit and blocks acceptance where configured.
4. Rewrite acceptance predicates include exception non-regression.

---

## 11. Homology of this document (explicit self-audit)

This step adds “exception correctness” as an additional boundary check on refactoring:

* **C₀**: exception paths (syntactic/semantic candidates)
* **C₁**: discharge witnesses (deadness/handledness)
* **C₂**: rewrite plans (transformations intended to eliminate/handle exceptions)
* **∂**: acceptance predicates now include exception-obligation closure
* **H₀**: the remaining (discharged) exception-free semantics under admitted environments
* **H₁**: residual exception holes (UNKNOWN obligations) — explicitly represented, not ignored

“holes” are not tolerated silently; they are carried as explicit obligations until eliminated.

---

## 12. Orthogonal implication braid (3×3×3, concise)

### N₁ ExceptionPath

* I₁.1 **Enumerability**: exception sources are listable

  * I₁.1.a E0 sites are syntactic
  * I₁.1.b E1 list is bounded and versioned
  * I₁.1.c E2 contracts are explicit
* I₁.2 **Stability**: IDs and ordering are stable

  * I₁.2.a stable selectors
  * I₁.2.b stable path IDs
  * I₁.2.c deterministic output
* I₁.3 **Auditability**: each path becomes an obligation

  * I₁.3.a status is explicit
  * I₁.3.b remainder is explicit
  * I₁.3.c witness refs are explicit

### N₂ Discharge

* I₂.1 **Deadness**: unreachable paths are proven

  * I₂.1.a environment explicit
  * I₂.1.b reduced core
  * I₂.1.c deterministic replay
* I₂.2 **Handledness**: reachable paths are dominated by handlers

  * I₂.2.a dominance evidence
  * I₂.2.b declared outcome boundary
  * I₂.2.c environment assumptions explicit
* I₂.3 **Unknown**: uncertainty is not elided

  * I₂.3.a remainder required
  * I₂.3.b blocks acceptance when configured
  * I₂.3.c deterministic persistence

### N₃ Refactoring coercion

* I₃.1 **Non-regression**: rewrites do not increase uncertainty

  * I₃.1.a UNKNOWN count non-increasing
  * I₃.1.b witness counts non-decreasing
  * I₃.1.c failures explicit
* I₃.2 **Progress**: rewrites convert obligations to discharged

  * I₃.2.a measurable improvements
  * I₃.2.b evidence attached
  * I₃.2.c verified by re-audit
* I₃.3 **Stability**: artifacts survive time

  * I₃.3.a snapshot capture
  * I₃.3.b latest selectors
  * I₃.3.c basis pinning

---

## 13. Commands (reference)

### Local checks

* `python -m pytest -q`
* `mise exec -- python scripts/docflow_audit.py --root .`

### Audit with exception obligations

* `gabion dataflow-audit --fingerprint-exception-obligations-json <path> ...`

### Snapshot capture

* `./audit_snapshot.sh`
* `./latest_snapshot.sh --fingerprint-exception-obligations`

(Flags must match repo CLI; this section is normative and must be kept aligned with implementation.)

---

## 14. Closing

`in-27` turns exception behavior into a proof obligation:

* exception paths must be dead or handled,
* evidence must be explicit and serialized,
* refactoring must not regress obligations,
* acceptance is determined by re-audit closure.

This is correctness-by-construction in the repo’s own idiom: evidence artifacts + determinism + snapshot reproducibility + enforced closure under tests.
