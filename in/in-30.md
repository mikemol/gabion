---
doc_revision: 21
reader_reintern: Reader-only: re-intern if doc_revision changed since you last read this doc.
doc_id: in_30
doc_role: in_step
doc_scope:
  - repo
  - tooling
  - semantics
  - analysis
doc_authority: normative
doc_owner: maintainer
doc_requires:
  - POLICY_SEED.md#policy_seed
  - glossary.md#aspf
  - glossary.md#forest
  - glossary.md#suite_site
  - glossary.md#hash_consing
  - glossary.md#decision_surface
  - glossary.md#ambiguity_set
  - glossary.md#partition_witness
  - CONTRIBUTING.md#contributing_contract
  - README.md#repo_contract
  - AGENTS.md#agent_obligations
  - in/in-28.md#in_in_28
  - in/in-23.md#in_in_23
  - in/in-29.md#in_in_29
doc_reviewed_as_of:
  POLICY_SEED.md#policy_seed: 1
  glossary.md#aspf: 1
  glossary.md#forest: 1
  glossary.md#suite_site: 1
  glossary.md#hash_consing: 1
  glossary.md#decision_surface: 1
  glossary.md#ambiguity_set: 1
  glossary.md#partition_witness: 1
  CONTRIBUTING.md#contributing_contract: 1
  README.md#repo_contract: 1
  AGENTS.md#agent_obligations: 1
  in/in-28.md#in_in_28: 1
  in/in-23.md#in_in_23: 1
  in/in-29.md#in_in_29: 1
doc_review_notes:
  POLICY_SEED.md#policy_seed: Reviewed POLICY_SEED.md rev1 (mechanized governance default; branch/tag CAS + check-before-use constraints); no conflicts with this document's scope.
  glossary.md#aspf: Reviewed glossary.md#aspf rev1 (ASPF carrier semantics + packed-forest labels).
  glossary.md#forest: Reviewed glossary.md#forest rev1 (Forest materialized carrier; interned identity; suite-locality facets).
  glossary.md#suite_site: Reviewed glossary.md#suite_site rev1 (SuiteSite locality carrier + containment semantics).
  glossary.md#hash_consing: Reviewed glossary.md#hash_consing rev1 (hash-consing/internment: hash==normalize; β-reduction via normalization rules).
  glossary.md#decision_surface: Reviewed glossary.md#decision_surface rev1 (decision surface tier boundary semantics).
  glossary.md#ambiguity_set: Reviewed glossary.md#ambiguity_set rev1 (ambiguity carriers are canonical, order-independent candidate sets).
  glossary.md#partition_witness: Reviewed glossary.md#partition_witness rev1 (ambiguity witnesses anchored to candidate sets with collapse hints).
  CONTRIBUTING.md#contributing_contract: Reviewed CONTRIBUTING.md rev1 (docflow now fails on missing GH references for SPPF-relevant changes); no conflicts with this document's scope.
  README.md#repo_contract: Reviewed README.md rev1 (docflow audit now scans in/ by default); no conflicts with this document's scope.
  AGENTS.md#agent_obligations: Agent obligations unchanged; suite carrier remains audit-driven.
  in/in-28.md#in_in_28: Reviewed in/in-28.md rev7 (template invariants updated pins).
  in/in-23.md#in_in_23: Reviewed in/in-23.md rev7 (HOL proof + embedded logical systems list + normalization-as-evaluation); no conflicts.
  in/in-29.md#in_in_29: Reviewed in/in-29.md rev16 (evidence dominance + updated in-23/24/25 pins); artifact paths aligned.
doc_change_protocol: POLICY_SEED.md#change_protocol
doc_erasure:
  - spelling/formatting only
  - reflow without semantic edits
  - comment-only changes
doc_sections:
  in_in_30: 1
doc_section_requires:
  in_in_30:
    - POLICY_SEED.md#policy_seed
    - glossary.md#aspf
    - glossary.md#forest
    - glossary.md#suite_site
    - glossary.md#hash_consing
    - glossary.md#decision_surface
    - glossary.md#ambiguity_set
    - glossary.md#partition_witness
    - CONTRIBUTING.md#contributing_contract
    - README.md#repo_contract
    - AGENTS.md#agent_obligations
    - in/in-28.md#in_in_28
    - in/in-23.md#in_in_23
    - in/in-29.md#in_in_29
doc_section_reviews:
  in_in_30:
    POLICY_SEED.md#policy_seed:
      dep_version: 1
      self_version_at_review: 1
      outcome: no_change
      note: Reviewed POLICY_SEED.md rev1 (mechanized governance default; branch/tag CAS + check-before-use constraints); no conflicts with this document's scope.
    glossary.md#aspf:
      dep_version: 1
      self_version_at_review: 1
      outcome: no_change
      note: Reviewed glossary.md#aspf rev1 (ASPF carrier semantics + packed-forest labels).
    glossary.md#forest:
      dep_version: 1
      self_version_at_review: 1
      outcome: no_change
      note: Reviewed glossary.md#forest rev1 (Forest materialized carrier; interned identity; suite-locality facets).
    glossary.md#suite_site:
      dep_version: 1
      self_version_at_review: 1
      outcome: no_change
      note: Reviewed glossary.md#suite_site rev1 (SuiteSite locality carrier + containment semantics).
    glossary.md#hash_consing:
      dep_version: 1
      self_version_at_review: 1
      outcome: no_change
      note: Reviewed glossary.md#hash_consing rev1 (hash-consing/internment: hash==normalize; β-reduction via normalization rules).
    glossary.md#decision_surface:
      dep_version: 1
      self_version_at_review: 1
      outcome: no_change
      note: Reviewed glossary.md#decision_surface rev1 (decision surface tier boundary semantics).
    glossary.md#ambiguity_set:
      dep_version: 1
      self_version_at_review: 1
      outcome: no_change
      note: Reviewed glossary.md#ambiguity_set rev1 (ambiguity carriers are canonical, order-independent candidate sets).
    glossary.md#partition_witness:
      dep_version: 1
      self_version_at_review: 1
      outcome: no_change
      note: Reviewed glossary.md#partition_witness rev1 (ambiguity witnesses anchored to candidate sets with collapse hints).
    CONTRIBUTING.md#contributing_contract:
      dep_version: 1
      self_version_at_review: 1
      outcome: no_change
      note: Reviewed CONTRIBUTING.md rev1 (docflow now fails on missing GH references for SPPF-relevant changes); no conflicts with this document's scope.
    README.md#repo_contract:
      dep_version: 1
      self_version_at_review: 1
      outcome: no_change
      note: Reviewed README.md rev1 (docflow audit now scans in/ by default); no conflicts with this document's scope.
    AGENTS.md#agent_obligations:
      dep_version: 1
      self_version_at_review: 1
      outcome: no_change
      note: Agent obligations unchanged; suite carrier remains audit-driven.
    in/in-28.md#in_in_28:
      dep_version: 1
      self_version_at_review: 1
      outcome: no_change
      note: Reviewed in/in-28.md rev7 (template invariants updated pins).
    in/in-23.md#in_in_23:
      dep_version: 1
      self_version_at_review: 1
      outcome: no_change
      note: Reviewed in/in-23.md rev7 (HOL proof + embedded logical systems list + normalization-as-evaluation); no conflicts.
    in/in-29.md#in_in_29:
      dep_version: 1
      self_version_at_review: 1
      outcome: no_change
      note: Reviewed in/in-29.md rev16 (evidence dominance + updated in-23/24/25 pins); artifact paths aligned.
---
<a id="in_in_30"></a>


# in/in-30.md
## SuiteSite as a Unifying Carrier
### Loop-Scoped Deadline Obligations and Suite Facets

## Purpose
Introduce **SuiteSite** as the primary locality carrier so deadline obligations,
ambiguity witnesses, and decision surfaces bind to suites (loop bodies, branch
bodies, etc.), not just functions. This resolves the loop-scope deadline error
and aligns the Forest/ProjectionSpec stack with Python's suite semantics.

## Non-goals
- This step does not immediately retire `FunctionSite`; it remains a projection.
- This step does not resolve all open semantics (outer vs inner loop propagation).
- This step does not refactor every facet in one phase; migration is staged.

## Status
Target design with a phased migration plan; implementation starts with loop
suites and deadline obligations.

Normative pointers (explicit): [POLICY_SEED.md#policy_seed](POLICY_SEED.md#policy_seed), [glossary.md#aspf](glossary.md#aspf), [glossary.md#forest](glossary.md#forest), [glossary.md#suite_site](glossary.md#suite_site), [glossary.md#hash_consing](glossary.md#hash_consing), [glossary.md#decision_surface](glossary.md#decision_surface), [glossary.md#ambiguity_set](glossary.md#ambiguity_set), [glossary.md#partition_witness](glossary.md#partition_witness), [CONTRIBUTING.md#contributing_contract](CONTRIBUTING.md#contributing_contract), [README.md#repo_contract](README.md#repo_contract), [AGENTS.md#agent_obligations](AGENTS.md#agent_obligations), [in/in-28.md#in_in_28](in/in-28.md#in_in_28), [in/in-23.md#in_in_23](in/in-23.md#in_in_23), [in/in-29.md#in_in_29](in/in-29.md#in_in_29).

## Definitions
- **SuiteSite:** A contiguous executable block (function body, loop body, branch).
- **Facet:** A property or witness attached to a SuiteSite (e.g., ambiguity).
- **Containment graph:** Parent-child relations between SuiteSites.

## Face / Kit / Solver

### Face (Obligations)
- **F1:** Emit SuiteSites (at least loop suites) with span + parent links.
- **F2:** Deadline obligations are checked inside each loop SuiteSite.
- **F3:** Aggregating suite facets to function scope reproduces legacy reports.

### Kit (Existing machinery)
- Forest/ASPF, ForestSpec, ProjectionSpec, dominance/delta machinery.
- Deadline checking helpers and audit/report pipeline.

### Solver (Implementation plan)
- Phase 0: emit SuiteSites (no behavior change).
- Phase 1: migrate ambiguity witnesses to suite scope.
- Phase 2: move deadline obligations to loop suites.
- Phase 3: migrate decision surfaces and never invariants.
- Phase 4: treat FunctionSite as a projection/alias.

## Artifact Contract
- Forest carries SuiteSite nodes with kind, span, path, qual, parent.
- Facets attach to SuiteSites; loop suites record deadline checks.
- Projection outputs remain deterministic and stable under re-audit.

## Admissibility
- Loop suites without in-body `check_deadline()` are reported as violations.
- Suite aggregation equals legacy function-level behavior until deprecation.

## Checks as Lemmas
- Check-before-loop fails to satisfy loop suite obligation.
- Check-inside-loop satisfies only the innermost loop suite.
- Aggregated suite witnesses match legacy function witnesses.

## Success Criteria
- Loop-scoped obligations are precise and deterministic.
- Backwards compatibility via suite-to-function aggregation holds.
- Forest signature stabilization confirmed by tests.

## Failure Modes and Diagnostics
- False passes if checks are outside loop suites.
- Missing suite nodes or unstable spans lead to nondeterministic artifacts.

## Commands
(Optional; to be defined during implementation).

## Appendix A: Detailed Design (Draft)

# SuiteSite: A Unifying Carrier for Structural Analysis in Gabion

**Status:** Target design
**Audience:** Maintainers, Codex (implementation agent)
**Last reviewed:** TBD

---

## 1. Problem Statement

Gabion’s analysis currently treats **functions** as the primary unit of structure. This is no longer sufficient.

Several recently introduced features expose the limitation:

* **Deadline enforcement** needs to distinguish *checks inside loop bodies* vs *outside loops*.
* **Ambiguity witnesses** are localized to specific control regions (e.g. a branch or callsite), not whole functions.
* **Decision surfaces** arise at conditionals, not function boundaries.
* **Call clusters** and **partition witnesses** naturally align to subsets of execution, not entire functions.

At the same time, Gabion already maintains:

* a graph-first ASPF (`Forest`)
* dominance/obsolescence reasoning
* ProjectionSpec as a normalized calculus over graph-derived relations

The missing piece is a **single, uniform locality carrier** that can represent *any executable or evaluable block* in Python.

---

## 2. Core Insight

In Python, the fundamental executable unit is a **suite**.

A *suite* is a sequence of statements executed as a block:

* function body
* loop body
* `if` / `else` body
* `try` / `except` / `finally` body
* class body
* module body

There is **no principled distinction** between:

```python
class C:
    x = 3
```

and

```python
def f():
    x = 3
```

Both are suites; one is evaluated at class creation time, the other at call time.

Therefore:

> **SuiteSite must become the primary carrier of locality.**
> All existing forest “specializations” are facets attached to SuiteSite, or projections over sets of SuiteSites.

---

## 3. ASPF / Forest / Suite Stack

This step relies on **three stacked semantics**, each already present in the codebase:

1. **ASPF (root carrier)**  
   The canonical, hash‑consed semantic carrier. ASPF is not a digest; it is
   the normalized representative. All other carriers are interned into ASPF,
   so their semantics inherit ASPF normalization.

2. **Forest (materialized carrier graph)**  
   The `Forest` is the operational form of ASPF: an interned graph of nodes
   and alternatives that stores identity, provenance, and facet structure.
   It does not add new semantics; it **materializes** ASPF structure so
   ProjectionSpec can query it deterministically.

3. **SuiteSite (locality carrier within the Forest)**  
   SuiteSites are **node kinds** in the Forest. They give locality a stable
   identity and allow facets (decision surfaces, ambiguity sets, never sinks,
   deadline checks) to attach to *specific suites* rather than whole functions.

This stack is the minimal semantics needed for precision:

```
ASPF (root normalization + identity)
 └── Forest (interned carrier graph)
      └── SuiteSite (locality nodes) + facets (evidence rows)
```

**Invariants:**

* Forest nodes are **interned** (hash‑consed) and stable under non‑semantic edits.
* SuiteSite identity is a canonical key in the Forest, not a derived alias.
* Facets always attach to SuiteSites; function‑level evidence is an aggregation.

---

## 4. Definitions

### 4.1 SuiteSite

A **SuiteSite** represents a contiguous executable block.

**Canonical fields:**

* `kind`: enum
  (`module_body`, `class_body`, `function_body`, `loop_body`, `if_body`, `else_body`, `try_body`, `except_body`, `finally_body`, …)
* `role`: optional semantic role
  (`body`, `handler`, `branch`, `guard`, …)
* `path`: file path (relative to project root)
* `qual`: fully-qualified enclosing symbol (if any)
* `span`: `[line, col, end_line, end_col]`
* `parent`: enclosing SuiteSite (or `None`)

### 4.2 Containment Graph

SuiteSites form a **tree (or DAG)** via containment:

```
ModuleSuite
 └── ClassSuite
      └── FunctionSuite
           └── LoopSuite
                └── IfSuite
```

This containment is **structural**, not semantic.

---

## 5. Relationship to Existing Carriers

### 5.1 FunctionSite

`FunctionSite` becomes a **specialization / alias** of SuiteSite:

* `FunctionSite ≡ SuiteSite(kind="function_body")`
* Existing FunctionSite nodes are preserved short-term for compatibility.
* Long-term, FunctionSite is a *projection* over SuiteSite.

### 5.2 Existing Forest Alt Kinds

All current forest alts become **facets attached to SuiteSite**:

| Current concept      | Becomes                                                |
| -------------------- | ------------------------------------------------------ |
| DecisionSurface      | Facet on SuiteSite containing the conditional          |
| ValueDecisionSurface | Same                                                   |
| NeverInvariantSink   | Facet on SuiteSite containing `never()`                |
| AmbiguitySet         | Facet on SuiteSite containing the ambiguous resolution |
| CallCluster          | Facet spanning multiple SuiteSites                     |
| Bundle forwarding    | Facet on SuiteSite containing the call                 |

No new “node zoo” is introduced — only **SuiteSite + facets**.

---

## 6. Why This Subsumes Everything

SuiteSite is the **greatest lower bound** of:

* data construction
* control flow
* execution scope
* evaluation context

Everything Gabion reasons about today can be expressed as:

> *Some property holds for this SuiteSite, possibly parameterized.*

Conversely, function-level reasoning is recovered by **aggregation**:

```text
FunctionFacet = aggregate(facets over SuiteSites contained by FunctionSuite)
```

This matches Gabion’s existing dominance and projection machinery.

---

## 7. SuiteSite and ProjectionSpec

SuiteSite aligns directly with ProjectionSpec:

* **Domain:** Forest (SuiteSites + facets)
* **Relations:** tables keyed by `suite_id`
* **Projections:** select / group / aggregate over suites

Example:

* Deadline obligations projection:

  * select SuiteSites with `kind=loop_body`
  * require `check_deadline` facet within same suite
* Ambiguity report:

  * group AmbiguitySet facets by SuiteSite
* Decision surface summary:

  * select SuiteSites containing conditionals

ProjectionSpec remains unchanged — only the base carrier improves.

---

## 7.0 Intuitionistic FOL over Interned Carriers

Gabion operates on **intuitionistic logic**, not classical logic. The forest
internment model provides a **finite, fully enumerated domain** (the set of
interned SuiteSites or facet rows). Therefore, classical FOL quantifiers are
translated into intuitionistic logic by **finite expansion** over the domain:

```
∀x φ(x)  ⇒  ⋀_{a ∈ D} φ(a)
∃x φ(x)  ⇒  ⋁_{a ∈ D} φ(a)
```

Operationally:

- **Universal obligations** are checked by requiring the **counterexample
  projection** to be empty (no witnesses).
- **Existential obligations** are checked by requiring the **witness
  projection** to be non‑empty.

This translation is valid because the domain is explicitly enumerated by
internment, so the quantifiers range over a finite carrier without invoking
classical excluded middle. In practice, `never()` obligations are already the
universal case: they assert that a counterexample set is empty.

**Internment/normalization contract:** hashing is **hash‑consing**: the hash
function *is* normalization. Regardless of the normalization status of the
input, `hash(x)` returns the normalized form, and `hash(hash(x)) == hash(x)`.
Hashes are addresses of normalized forms only; raw objects are not separately
addressable, and hash must not lose information (no digest semantics).
Any computation intended to be intrinsic (including β‑reduction or call‑like
substitution) must be defined as a normalization rule prior to internment.
Because internment is hash‑consing, **β‑reduction is intrinsic and automatic
to internment** whenever it is part of the normalization system.

**Carrier inheritance:** ASPF is the **root carrier**. All other carriers
(docflow, GitHub suites, ProjectionSpec‑emitted relations) are interned into
ASPF, so their evaluation inherits ASPF normalization. Required reductions are
expressed as normalization rules on carrier syntax; **construction + internment
is the evaluation**.

---

## 7.1 SuiteSite Domains (Docflow + GitHub)

Docflow inputs are suites. Treat documents and issue metadata as SuiteSites so
the DSL operates uniformly over carriers. The **identity key** is:

```
(domain, kind, path, qual, span)
```

where `span = (line, col, end_line, end_col)` and `domain ∈ {docflow, github}`.

### Docflow suites (emitted)
- `doc_file`: the full markdown file (span = whole file).
  - `path`: repo-relative path.
  - `qual`: `doc_id` if present, otherwise `path`.
- `frontmatter`: YAML frontmatter block (span = YAML block lines).
- `section`: a heading block (`#` … to next heading).
  - `qual`: `${doc_qual}#${heading_slug}`.
- `list_item`: a single bullet item (span = line).
  - `qual`: `${doc_qual}::item:${line_no}`.
- `sppf_item`: any line (list item or free line) containing `sppf{...}`.
  - `qual`: `${doc_qual}::sppf:${line_no}`.

### GitHub suites (emitted)
- `issue`: a SuiteSite representing the issue object itself.
  - `path/qual`: `GH-<n>`.
  - `span`: virtual `(0,0,0,0)` (no text span; metadata-only).
- `issue_body`: suite covering the issue body (span = body lines).
- `issue_checklist_item`: one suite per checklist item (span = item line).

### GitHub suites (planned)
- `issue_body_section`: suite for structured body sections (heading blocks).

### Facets (rows keyed by SuiteSite)
Docflow and GitHub metadata attach as facets (rows keyed by `suite_key`).
Examples:

- `frontmatter_field`, `frontmatter_item`, `frontmatter_entry`
- `section_meta`, `list_item_meta`, `sppf_item`
- `issue_meta`, `issue_label`

### Relations
- `SuiteContains` edges tie suites to parents.
- `SuiteRef` edges tie docflow SPPF suites → GitHub issue suites.

This keeps docflow invariants in the same carrier space as code analysis:
SuiteSite + facets → ProjectionSpec → invariants.

---

## 7.2 Embedded Logical Systems (Already Present)

The following systems are **already embedded** without adding primitives,
because they are reducible to interned carriers + ProjectionSpec:

1. **Finite‑domain intuitionistic FOL**
   - Domain = interned carriers (SuiteSites + facets).
   - `∀` / `∃` reduce to finite conjunction/disjunction via counterexample or
     witness projections.

2. **Relational algebra / SQL (select‑project‑aggregate fragment)**
   - `select`, `project`, `count_by`, `sort`, `limit` are native.
   - Joins are represented by **multi‑suite facets** (pre‑joined carriers).

3. **Datalog over pre‑joined relations**
   - Stratified rules collapse to selections over emitted relations.
   - No new evaluator primitives required; joins are already encoded.

4. **Simply‑typed lambda calculus (extensional equality)**
   - β‑reduction is intrinsic to internment (hash‑consing normalization).
   - Equality is by normalized form; evaluation is internment.

5. **Dependent eliminators (Π/Σ over finite carriers)**
   - ProjectionSpec acts as dependent elimination over interned domains.

These embeddings are **extensional**: they rely on carrier emission and
normalization, not on additional evaluator operations.

---

## 7.3 HOL via Internment (Proof Sketch)

**Goal:** show that higher‑order evaluation reduces to **construction + internment**.

**Required reductions:**
- β‑reduction
- α‑equivalence
- finite‑domain quantifier expansion

**Existing machinery:**
- Hash‑consing internment (normalization is intrinsic).
- SuiteSite + facets provide a **finite, enumerated domain**.
- ProjectionSpec yields counterexample/witness projections.

**Lemma chain:**
1. **β‑reduction** is intrinsic to internment (hash‑consing normalization).
2. **α‑equivalence** is enforced by binder normalization (renaming erased).
3. **∀/∃** over finite domains reduce to counterexample emptiness or witness existence.
4. Required reductions are **expressible as normalization rules** on ASPF
   carriers, so internment performs the evaluation.
5. Therefore, **parsing + internment** yields the normalized representative that
   an evaluator would compute.

**Conclusion:** HOL evaluation is already embedded as **construction** provided
normalization rules include the required reductions.

---

## 8. Implementation Plan (Phased)

### Phase 0 — Introduce SuiteSite (No Behavior Change)

* Add `SuiteSite` node kind to ASPF.
* Emit SuiteSites during AST traversal:

  * module
  * class
  * function
  * loop
  * branch
* Add containment edges.

**Acceptance:**

* Forest signature changes but existing reports unchanged.
* Tests validate deterministic SuiteSite emission.

---

### Phase 1 — Migrate Ambiguity Witnesses (First Subsumption)

* Emit AmbiguitySet facets at SuiteSite level.
* Keep existing function-scoped ambiguity output.
* Add a projection asserting:

  * aggregation(suite ambiguities) == function ambiguities

**Why ambiguity first:**
It is already structurally localized and benefits immediately.

---

### Phase 2 — Deadline Obligations (Loop Precision)

* Track `check_deadline()` per **loop SuiteSite**.
* Emit deadline obligations at loop suites.
* Retire function-level `loop=True` heuristic.

This directly fixes the issue you identified.

---

### Phase 3 — Decision Surfaces and Never Invariants

* Attach decision surfaces to the suite containing the conditional.
* Attach never sinks to the suite containing the call.
* Update reports to prefer suite facets.

---

### Phase 4 — Retire FunctionSite as Primary

* FunctionSite becomes a projection / alias.
* All new facets are suite-native.
* Backwards compatibility maintained via projections.

---

## 9. Invariants and Laws

The design is constrained by explicit laws:

1. **Containment Soundness**
   Every facet must attach to exactly one SuiteSite.

2. **Aggregation Consistency**
   Aggregating suite facets to function scope must reproduce legacy behavior (until retired).

3. **Dominance Monotonicity**
   Introducing SuiteSites must strictly increase or preserve analytical precision.

4. **Projection Idempotence**
   Suite-based ProjectionSpecs normalize to stable spec IDs.

---

## 10. Why This Enables Self-Hosting

Once SuiteSite is primary:

* Gabion can analyze **its own suites**.
* Ambiguities in Gabion’s analysis code become first-class.
* Gabion can propose:

  * suite specializations
  * facet refinements
  * projection rewrites

This is the point where:

> **analysis code, analysis data, and execution structure converge.**

Not metaphorically — *structurally*.

---

## 11. Open Semantics (Explicitly Deferred)

These are **deliberate design knobs**, not oversights:

* Nested loop semantics (inner vs outer satisfaction)
* Recursive suite satisfaction
* Cross-suite obligation propagation

They are deferred until SuiteSite exists, because only then can they be expressed cleanly.

---

## 12. Summary

* SuiteSite is the missing base carrier.
* It subsumes all existing forest specializations.
* It aligns perfectly with ProjectionSpec and dominance reasoning.
* It enables loop-correct deadlines, precise ambiguities, and self-hosting analysis.
* Migration is incremental, testable, and non-disruptive.
