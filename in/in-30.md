---
doc_revision: 1
reader_reintern: "Reader-only: re-intern if doc_revision changed since you last read this doc."

doc_id: in_30
doc_role: in_step
doc_scope:
  - repo
  - tooling
  - semantics
  - analysis

doc_authority: normative
doc_owner: maintainer

doc_requires:
  - POLICY_SEED.md
  - glossary.md
  - CONTRIBUTING.md
  - README.md
  - AGENTS.md
  - in/in-28.md
  - in/in-23.md
  - in/in-29.md

doc_reviewed_as_of:
  POLICY_SEED.md: 33
  glossary.md: 29
  CONTRIBUTING.md: 78
  README.md: 59
  AGENTS.md: 13
  in/in-28.md: 2
  in/in-23.md: 1
  in/in-29.md: 10
doc_review_notes:
  POLICY_SEED.md: "Reviewed POLICY_SEED.md rev33 (mechanized governance default; branch/tag CAS + check-before-use constraints); no conflicts with this document's scope."
  glossary.md: "Reviewed glossary rev29 (obsolescence projection path + self-review/mirror definitions); suite/loop terminology unchanged."
  CONTRIBUTING.md: "Reviewed CONTRIBUTING.md rev77 (docflow now fails on missing GH references for SPPF-relevant changes); no conflicts with this document's scope."
  README.md: "Reviewed README.md rev59 (docflow audit now scans in/ by default); no conflicts with this document's scope."
  AGENTS.md: "Agent obligations unchanged; suite carrier remains audit-driven."
  in/in-28.md: "Structured to match the in_step template."
  in/in-23.md: "Builds on ASPF carrier framing; no conflicts."
  in/in-29.md: "Dominance/delta framing informs suite aggregation; artifact paths aligned."

doc_change_protocol: "POLICY_SEED.md §6"
doc_erasure:
  - "spelling/formatting only"
  - "reflow without semantic edits"
  - "comment-only changes"
---

# in/in-30.md
## SuiteSite as a Unifying Carrier
### Loop-Scoped Deadline Obligations and Suite Facets

## Purpose
Introduce **SuiteSite** as the primary locality carrier so deadline obligations,
ambiguity witnesses, and decision surfaces bind to suites (loop bodies, branch
bodies, etc.), not just functions. This resolves the loop-scope deadline error
and aligns the Forest/ProjectionSpec stack with Python's suite semantics.

## Non-goals
- This step does not immediately retire `FunctionSite`; it remains a projection.
- This step does not resolve all open semantics (outer vs inner loop propagation).
- This step does not refactor every facet in one phase; migration is staged.

## Status
Target design with a phased migration plan; implementation starts with loop
suites and deadline obligations.

Normative pointers (explicit): `POLICY_SEED.md`, `glossary.md`, `CONTRIBUTING.md`, `README.md`, `AGENTS.md`, `in/in-28.md`, `in/in-23.md`, `in/in-29.md`.

## Definitions
- **SuiteSite:** A contiguous executable block (function body, loop body, branch).
- **Facet:** A property or witness attached to a SuiteSite (e.g., ambiguity).
- **Containment graph:** Parent-child relations between SuiteSites.

## Face / Kit / Solver

### Face (Obligations)
- **F1:** Emit SuiteSites (at least loop suites) with span + parent links.
- **F2:** Deadline obligations are checked inside each loop SuiteSite.
- **F3:** Aggregating suite facets to function scope reproduces legacy reports.

### Kit (Existing machinery)
- Forest/ASPF, ForestSpec, ProjectionSpec, dominance/delta machinery.
- Deadline checking helpers and audit/report pipeline.

### Solver (Implementation plan)
- Phase 0: emit SuiteSites (no behavior change).
- Phase 1: migrate ambiguity witnesses to suite scope.
- Phase 2: move deadline obligations to loop suites.
- Phase 3: migrate decision surfaces and never invariants.
- Phase 4: treat FunctionSite as a projection/alias.

## Artifact Contract
- Forest carries SuiteSite nodes with kind, span, path, qual, parent.
- Facets attach to SuiteSites; loop suites record deadline checks.
- Projection outputs remain deterministic and stable under re-audit.

## Admissibility
- Loop suites without in-body `check_deadline()` are reported as violations.
- Suite aggregation equals legacy function-level behavior until deprecation.

## Checks as Lemmas
- Check-before-loop fails to satisfy loop suite obligation.
- Check-inside-loop satisfies only the innermost loop suite.
- Aggregated suite witnesses match legacy function witnesses.

## Success Criteria
- Loop-scoped obligations are precise and deterministic.
- Backwards compatibility via suite-to-function aggregation holds.
- Forest signature stabilization confirmed by tests.

## Failure Modes and Diagnostics
- False passes if checks are outside loop suites.
- Missing suite nodes or unstable spans lead to nondeterministic artifacts.

## Commands
(Optional; to be defined during implementation).

## Appendix A: Detailed Design (Draft)

# SuiteSite: A Unifying Carrier for Structural Analysis in Gabion

**Status:** Target design
**Audience:** Maintainers, Codex (implementation agent)
**Last reviewed:** TBD

---

## 1. Problem Statement

Gabion’s analysis currently treats **functions** as the primary unit of structure. This is no longer sufficient.

Several recently introduced features expose the limitation:

* **Deadline enforcement** needs to distinguish *checks inside loop bodies* vs *outside loops*.
* **Ambiguity witnesses** are localized to specific control regions (e.g. a branch or callsite), not whole functions.
* **Decision surfaces** arise at conditionals, not function boundaries.
* **Call clusters** and **partition witnesses** naturally align to subsets of execution, not entire functions.

At the same time, Gabion already maintains:

* a graph-first ASPF (`Forest`)
* dominance/obsolescence reasoning
* ProjectionSpec as a normalized calculus over graph-derived relations

The missing piece is a **single, uniform locality carrier** that can represent *any executable or evaluable block* in Python.

---

## 2. Core Insight

In Python, the fundamental executable unit is a **suite**.

A *suite* is a sequence of statements executed as a block:

* function body
* loop body
* `if` / `else` body
* `try` / `except` / `finally` body
* class body
* module body

There is **no principled distinction** between:

```python
class C:
    x = 3
```

and

```python
def f():
    x = 3
```

Both are suites; one is evaluated at class creation time, the other at call time.

Therefore:

> **SuiteSite must become the primary carrier of locality.**
> All existing forest “specializations” are facets attached to SuiteSite, or projections over sets of SuiteSites.

---

## 3. Definitions

### 3.1 SuiteSite

A **SuiteSite** represents a contiguous executable block.

**Canonical fields:**

* `kind`: enum
  (`module_body`, `class_body`, `function_body`, `loop_body`, `if_body`, `else_body`, `try_body`, `except_body`, `finally_body`, …)
* `role`: optional semantic role
  (`body`, `handler`, `branch`, `guard`, …)
* `path`: file path (relative to project root)
* `qual`: fully-qualified enclosing symbol (if any)
* `span`: `[line, col, end_line, end_col]`
* `parent`: enclosing SuiteSite (or `None`)

### 3.2 Containment Graph

SuiteSites form a **tree (or DAG)** via containment:

```
ModuleSuite
 └── ClassSuite
      └── FunctionSuite
           └── LoopSuite
                └── IfSuite
```

This containment is **structural**, not semantic.

---

## 4. Relationship to Existing Carriers

### 4.1 FunctionSite

`FunctionSite` becomes a **specialization / alias** of SuiteSite:

* `FunctionSite ≡ SuiteSite(kind="function_body")`
* Existing FunctionSite nodes are preserved short-term for compatibility.
* Long-term, FunctionSite is a *projection* over SuiteSite.

### 4.2 Existing Forest Alt Kinds

All current forest alts become **facets attached to SuiteSite**:

| Current concept      | Becomes                                                |
| -------------------- | ------------------------------------------------------ |
| DecisionSurface      | Facet on SuiteSite containing the conditional          |
| ValueDecisionSurface | Same                                                   |
| NeverInvariantSink   | Facet on SuiteSite containing `never()`                |
| AmbiguitySet         | Facet on SuiteSite containing the ambiguous resolution |
| CallCluster          | Facet spanning multiple SuiteSites                     |
| Bundle forwarding    | Facet on SuiteSite containing the call                 |

No new “node zoo” is introduced — only **SuiteSite + facets**.

---

## 5. Why This Subsumes Everything

SuiteSite is the **greatest lower bound** of:

* data construction
* control flow
* execution scope
* evaluation context

Everything Gabion reasons about today can be expressed as:

> *Some property holds for this SuiteSite, possibly parameterized.*

Conversely, function-level reasoning is recovered by **aggregation**:

```text
FunctionFacet = aggregate(facets over SuiteSites contained by FunctionSuite)
```

This matches Gabion’s existing dominance and projection machinery.

---

## 6. SuiteSite and ProjectionSpec

SuiteSite aligns directly with ProjectionSpec:

* **Domain:** Forest (SuiteSites + facets)
* **Relations:** tables keyed by `suite_id`
* **Projections:** select / group / aggregate over suites

Example:

* Deadline obligations projection:

  * select SuiteSites with `kind=loop_body`
  * require `check_deadline` facet within same suite
* Ambiguity report:

  * group AmbiguitySet facets by SuiteSite
* Decision surface summary:

  * select SuiteSites containing conditionals

ProjectionSpec remains unchanged — only the base carrier improves.

---

## 7. Implementation Plan (Phased)

### Phase 0 — Introduce SuiteSite (No Behavior Change)

* Add `SuiteSite` node kind to ASPF.
* Emit SuiteSites during AST traversal:

  * module
  * class
  * function
  * loop
  * branch
* Add containment edges.

**Acceptance:**

* Forest signature changes but existing reports unchanged.
* Tests validate deterministic SuiteSite emission.

---

### Phase 1 — Migrate Ambiguity Witnesses (First Subsumption)

* Emit AmbiguitySet facets at SuiteSite level.
* Keep existing function-scoped ambiguity output.
* Add a projection asserting:

  * aggregation(suite ambiguities) == function ambiguities

**Why ambiguity first:**
It is already structurally localized and benefits immediately.

---

### Phase 2 — Deadline Obligations (Loop Precision)

* Track `check_deadline()` per **loop SuiteSite**.
* Emit deadline obligations at loop suites.
* Retire function-level `loop=True` heuristic.

This directly fixes the issue you identified.

---

### Phase 3 — Decision Surfaces and Never Invariants

* Attach decision surfaces to the suite containing the conditional.
* Attach never sinks to the suite containing the call.
* Update reports to prefer suite facets.

---

### Phase 4 — Retire FunctionSite as Primary

* FunctionSite becomes a projection / alias.
* All new facets are suite-native.
* Backwards compatibility maintained via projections.

---

## 8. Invariants and Laws

The design is constrained by explicit laws:

1. **Containment Soundness**
   Every facet must attach to exactly one SuiteSite.

2. **Aggregation Consistency**
   Aggregating suite facets to function scope must reproduce legacy behavior (until retired).

3. **Dominance Monotonicity**
   Introducing SuiteSites must strictly increase or preserve analytical precision.

4. **Projection Idempotence**
   Suite-based ProjectionSpecs normalize to stable spec IDs.

---

## 9. Why This Enables Self-Hosting

Once SuiteSite is primary:

* Gabion can analyze **its own suites**.
* Ambiguities in Gabion’s analysis code become first-class.
* Gabion can propose:

  * suite specializations
  * facet refinements
  * projection rewrites

This is the point where:

> **analysis code, analysis data, and execution structure converge.**

Not metaphorically — *structurally*.

---

## 10. Open Semantics (Explicitly Deferred)

These are **deliberate design knobs**, not oversights:

* Nested loop semantics (inner vs outer satisfaction)
* Recursive suite satisfaction
* Cross-suite obligation propagation

They are deferred until SuiteSite exists, because only then can they be expressed cleanly.

---

## 11. Summary

* SuiteSite is the missing base carrier.
* It subsumes all existing forest specializations.
* It aligns perfectly with ProjectionSpec and dominance reasoning.
* It enables loop-correct deadlines, precise ambiguities, and self-hosting analysis.
* Migration is incremental, testable, and non-disruptive.
