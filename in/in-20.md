---
doc_revision: 1
reader_reintern: "Reader-only: re-intern if doc_revision changed since you last read this doc."
doc_id: in_20
doc_role: inbox
doc_scope:
  - repo
  - inbox
doc_authority: informative
doc_owner: maintainer
doc_requires:
doc_reviewed_as_of:
doc_review_notes:
doc_change_protocol: "POLICY_SEED.md §6"
doc_erasure:
  - formatting
  - typos
---
# in-20: Type Factorization and Prime-Labeled Grammar Compression

## Problem

Gabion currently represents parameter bundles and function signatures in literal or structural form. This limits its ability to deduplicate equivalent constructs, detect substructure relationships algebraically, or compress structural grammar space for large-scale analysis.

There is no canonical representation of compound types, and glossary entries do not participate in structural arithmetic. As a result, bundle overlap, subtyping, or co-occurrence patterns are computed via matching or enumeration rather than algebraic reasoning.

## Premise

Each primitive type (e.g. `int`, `str`, `list`) can be assigned a unique prime number. Composite types are then represented as the **product of their constituent primes**, following the **Fundamental Theorem of Arithmetic**. This enables canonical, reversible, and lossless encoding of type structure.

Named types (e.g. `User`, `Config`, `Settings`) are defined as **equivalence classes** over these products. Gabion can use this representation to detect structural overlap, embed factorization awareness into glossary terms, and compute bundle identity via GCD, LCM, and modular arithmetic.

## Goals

* Represent all type expressions as **integers composed of prime factors**.
* Support bundle deduplication via factor comparison (`gcd`, `lcm`).
* Enable fast detection of substructure, divergence, or alignment.
* Treat named types as pointers to factorizable equivalence classes.
* Integrate glossary entries with prime-compressed type fingerprints.

## Proposed Implementation

1. **Prime Assignment Map**

   ```toml
   [primes]
   int = 2
   str = 3
   list = 5
   dict = 7
   float = 11
   bool = 13
   ...
   ```

2. **Type Expression Encoding**

   ```python
   'List[int]' => 5 * 2 = 10
   'Dict[str, List[int]]' => 7 * 3 * 5 * 2 = 210
   'User' => prime_modulo(210)
   ```

3. **Canonical Operations**

   * `gcd(a, b)`: common substructure
   * `lcm(a, b)`: composite expression
   * `a % b == 0`: subtyping or subsumption
   * `xor(a, b)`: structural difference

4. **Glossary Entry Indexing**

   * Each glossary concept has a prime product representation.
   * Type-level matching becomes arithmetic.
   * CI audits can detect when unknown type fingerprints appear.

5. **Synthesis Normalization**

   * Rewrite structurally redundant expressions into canonical prime products.
   * Suggest naming bundles based on detected prime factors.

## Example

Function signature:

```python
def handle(user_id: int, username: str, flags: list[int]):
```

Type product:

```
2 (int) * 3 (str) * 5 (list) * 2 (int) = 60
```

Detected:

* `int` appears twice (multiple of 2²)
* `list[int]` present
* Structural fingerprint: 60

Glossary:

```toml
[user_context]
fingerprint = 60
```

Gabion emits:

```
✓ Match: bundle fingerprint 60 maps to glossary entry 'user_context'
✓ Suggest refactor to named bundle 'user_context'
```

## Dependencies

* Prime map registry (shared across grammar and synthesis passes)
* Expression parser to reduce compound types to atomic bases
* Glossary support for fingerprint annotation

## Acceptance Criteria

* Bundle synthesis emits fingerprint integer
* Glossary match detected via GCD or equality
* CI emits warning on unknown factor products
* At least one rewrite generated using canonical prime product

---

Proposed by: semantic factorization
Related: in-3 (bundles), in-17 (reuse), in-19 (dependent typing)
Status: draft
