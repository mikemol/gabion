from __future__ import annotations

from gabion.synthesis import emission
from gabion.synthesis.emission import render_protocol_stubs


# gabion:evidence E:call_footprint::tests/test_synthesis_contextvar_emission.py::test_contextvar_emission_single_ambient_value_snapshot::emission.py::gabion.synthesis.emission.render_protocol_stubs
def test_contextvar_emission_single_ambient_value_snapshot() -> None:
    plan = {
        "protocols": [
            {
                "name": "RequestBundle",
                "bundle": ["request_id"],
                "tier": 2,
                "rationale": "Tier-2 bundle",
                "evidence": ["control_context", "decision_surface"],
                "fields": [{"name": "request_id", "type_hint": "str"}],
            }
        ]
    }

    output = render_protocol_stubs(plan, kind="contextvar")

    assert output == (
        "# Auto-generated by gabion dataflow audit.\n"
        "from __future__ import annotations\n"
        "\n"
        "from typing import Any, ContextVar, TypeVar\n"
        "\n"
        "_ContextVarT = TypeVar(\"_ContextVarT\")\n"
        "\n"
        "\n"
        "def _read_contextvar(name: str, carrier: ContextVar[_ContextVarT], default: _ContextVarT) -> _ContextVarT:\n"
        "    \"\"\"Typed helper for reading an ambient context value.\"\"\"\n"
        "    return carrier.get(default)\n"
        "\n"
        "\n"
        "# Suggested ambient bundle: RequestBundle (tier 2)\n"
        "# Bundle fields: request_id\n"
        "# Rationale: Tier-2 bundle\n"
        "# Evidence: control_context, decision_surface\n"
        "_request_id_context: ContextVar[str] = ContextVar(\"request_id\")\n"
        "\n"
        "def get_request_id(default: str) -> str:\n"
        "    \"\"\"Read ambient `request_id` from `_request_id_context`.\"\"\"\n"
        "    return _read_contextvar(\"request_id\", _request_id_context, default)\n"
        "\n"
    )


# gabion:evidence E:call_footprint::tests/test_synthesis_contextvar_emission.py::test_contextvar_emission_grouped_bundle_snapshot::emission.py::gabion.synthesis.emission.render_protocol_stubs
def test_contextvar_emission_grouped_bundle_snapshot() -> None:
    plan = {
        "protocols": [
            {
                "name": "CtxBundle",
                "bundle": ["tenant", "request_id"],
                "tier": 2,
                "rationale": "Tier-2 bundle",
                "evidence": ["decision_surface", "control_context"],
                "fields": [
                    {"name": "tenant", "type_hint": "str"},
                    {"name": "request_id", "type_hint": "str"},
                ],
            }
        ]
    }

    output = render_protocol_stubs(plan, kind="contextvar")

    assert "# Bundle fields: request_id, tenant" in output
    assert output.index("_request_id_context") < output.index("_tenant_context")
    assert "def get_request_id(default: str) -> str:" in output
    assert "def get_tenant(default: str) -> str:" in output


# gabion:evidence E:call_footprint::tests/test_synthesis_contextvar_emission.py::test_contextvar_emission_unsupported_case_remains_advisory_snapshot::emission.py::gabion.synthesis.emission.render_protocol_stubs
def test_contextvar_emission_unsupported_case_remains_advisory_snapshot() -> None:
    plan = {
        "protocols": [
            {
                "name": "UnclearBundle",
                "bundle": ["mode"],
                "tier": 3,
                "rationale": "Tier-3 bundle",
                "evidence": ["dataflow"],
                "fields": [{"name": "mode", "type_hint": "str | int"}],
            }
        ]
    }

    output = render_protocol_stubs(plan, kind="contextvar")

    assert "Advisory only: missing control_context evidence" in output
    assert "_mode_context: ContextVar[str | int]" in output


# gabion:evidence E:function_site::emission.py::gabion.synthesis.emission.render_protocol_stubs
def test_render_protocol_stubs_covers_invalid_kind_typing_and_empty_fields() -> None:
    output = render_protocol_stubs(
        {
            "protocols": [
                {
                    "name": "MaybeBundle",
                    "tier": 2,
                    "bundle": ["9 bad-name", ""],
                    "rationale": "demo",
                    "fields": [
                        {"name": "maybe", "type_hint": "Optional[int]"},
                        {"name": "either", "type_hint": "Union[int, str]"},
                    ],
                    "evidence": ["control_context"],
                },
                {
                    "name": "EmptyBundle",
                    "tier": 3,
                    "bundle": [],
                    "rationale": "empty",
                    "fields": [],
                    "evidence": [],
                },
            ]
        },
        kind="invalid-kind",
    )
    assert "from dataclasses import dataclass" in output
    assert "Optional" in output
    assert "Union" in output
    assert "class TODO_Name_Me2:" in output
    assert "pass" in output


# gabion:evidence E:function_site::emission.py::gabion.synthesis.emission._sanitize_contextvar_identifier E:function_site::emission.py::gabion.synthesis.emission._sorted_protocols
def test_emission_helpers_cover_identifier_and_protocol_guardrails() -> None:
    assert emission._sanitize_contextvar_identifier("!!!") == "ambient"
    assert emission._sanitize_contextvar_identifier("9lives") == "ambient_9lives"
    assert emission._sorted_protocols({"protocols": "bad"}) == []
